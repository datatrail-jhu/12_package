[["index.html", "Course Name About this Course", " Course Name April, 2022 About this Course This course is part of a series of courses for DataTrail. DataTrail is a no-cost, paid 14-week educational initiative for young-adult, high school and GED-graduates. DataTrail aims to equip members of underserved communities with the necessary skills and support required to work in the booming field of data science. DataTrail is a fresh take on workforce development that focuses on training both Black, Indigenous, and other people of color (BIPOC) interested in the data science industry and their potential employers. Offered by the Johns Hopkins Bloomberg School of Public Health, in partnership with local non-profits and Leanpub, DataTrail combines a mutually-intensive learning experience (MILE) with a whole-person ecosystem of support to allow aspiring data scientists and their employers to succeed. DataTrail uses mutually-intensive learning DataTrail joins aspiring data science scholars and expert-level data scientist mentors in a mutually-intensive learning experience (MILE). In the DataTrail MILE: Scholars engage in cutting-edge technical and soft skills training needed to enter the data science field. Mentors engage in anti-racism and mentorship training needed to be impactful mentors and informed colleagues on diverse data science teams. The social connections created along the way will fuel job opportunities for scholars and foster a more diverse, equitable, and inclusive climate at the mentors’ institutions. { course-completeness: 100 course-attempts: 2 default-quiz-attempts: 2 default-random-choice-order: true default-quiz-show-answers: none } "],["building-r-packages.html", "Chapter 1 Building R Packages", " Chapter 1 Building R Packages This course will introduce you to all you need to know to get writing your own R packages. You’ll learn about the structure of R packages, how to incorporate code, as well as how to document your code so that it’s most easily usable by others (and future you)! Note: This first lesson should sound very familiar. If it doesn’t, we recommend you return to earlier courses in Cloud-Based Data Science to learn the basics of R before you embark on writing R packages of your own. 1.0.1 R Packages Earlier in this course set when we first started programming in R, we introduced the basics of R packages. We noted at that point in time that when you open up R, you have certain functionalities available to you. What is available to you when you first open R is known as base R. For example, when you first open R, you are able to calculate the mean (average) of a bunch of numbers. Specifically, by this point you’re well aware that mean(c(3,4,5)) returns 4, the average of the numbers 3, 4, and 5. However, not everything that’s possible in R is available to you every time you open up R or RStudio. This is done intentionally. There is a lot you can do with R; however, if all of that was made available every time you opened up R, it would take a long time for R to load and open. Rather, R makes some functionality available from base R (the mean() function, for example), while storing other functionality in packages. You’re likely very familiar with a number of packages at this point. You’ve probably used ggplot2 to generate plots, tidyr and diplyr to work with tabular data, and stringr, forcats, &amp; lubridate to make working with strings, factors, and dates (respectively) simpler. All of these packages contain R code that, when installed and loaded into R, makes their functionality available to the user. More specifically, a package is a collection of functions, data, and code conveniently provided in a nice, complete format for you. At the time of writing, there are just over 17,600 packages available to download - each with their own specialized functions and code, all developed for a specific but different purpose. What we haven’t talked about previously, however, is that you too can write R packages. In fact, anyone can and should write R packages!  Writing your own R package is helpful: whenever you find yourself copying and pasting code and functions over and over again. If you do, stop, and store that functionality in a package. That way, any time you want to re-use that code, you simply load your package in and get to work! whenever you want to share code and/or analyses with others. Storing data, code, and results in a package is a great way to share your work with others. when you come up with some functionality that others may want to use. You can share your packages on GitHub or CRAN (discussed more below) so that others have access to your package’s functionality! 1.0.1.0.1 Repositories? For R packages, a repository is central location where many developed packages are located and available for download. There are three big repositories for R packages: 1. CRAN (Comprehensive R Archive Network): R’s main repository (&gt;12,100 packages available!) 2. GitHub: A very popular, open source repository (not R specific!) 3. BioConductor: A repository mainly for bioinformatic-focused packages We note BioConductor here for completeness’ sake, but as these courses are not biology-focused, we’ll stick to discussing CRAN and GitHub throughout this course. 1.0.2 Installing, Loading, &amp; Updating As a refresher and to make sure we’re all on the same page before moving forward, we’ll review the basics of installing, loading and updating R packages. 1.0.2.1 Installing As a brief refresher, if you are installing from the CRAN repository, use the install.packages() function, with the name of the package you want to install in quotes between the parentheses . For example, if you want to install the package ggplot2, you would use: install.packages(\"ggplot2\")  From GitHub, installation occurs using devtools::install_github(\"author/package\") replacing “author” and “package” with their GitHub username and the name of the package.  1.0.2.2 Loading Installing a package does not make its functions immediately available to you. After installation to make the functions available to you, you must load the package into R. To do so, use the library() function. Think of this like any other software you install on your computer. Just because you’ve installed a program, doesn’t mean it’s automatically running - you have to open the program. Same with R. You’ve installed it, but now you have to “open” it. For example, to “open” the ggplot2 package, you would run:library(ggplot2) NOTE: Unlike when you’re installing a package, when loading a package, you do not have to put the package name in quotes.  There is an order to loading packages - some packages require other packages to be loaded first. These other packages are known as dependencies. When you install a new package, that new package’s manual/help pages will automatically determine what packages this new package is dependent upon and will install those packages as well. We’ll discuss this in more detail in a later lesson in this course. 1.0.2.3 Updating Good packages are updated over time - bugs are fixed and new functionality is sometimes added. This means that from time to time, you’ll have to update the package you’ve previously installed to a newer version. To update all packages, use update.packages(). If you only want to update a specific package, just use once again install.packages(\"packagename\") 1.0.3 Summary This lesson is meant to remind you of the basics of R packages - where to find them, how to install them, and why we use them. But, it’s also meant to set you up in the mindset to get excited to write your own packages! The remaining lessons in this course will get you started with making your first R package! We’ve linked to a number of helpful resources below, and we’ll be using content from a number of them throughout the course. 1.0.4 Additional Resources Introduction to R Packages, from Ken Rice and Timothy Thornton Writing An R Package From Scratch, by Hilary Parker R Packages, by Hadley Wickham 1.0.5 Slides and Video Packages Slides "],["overview.html", "Chapter 2 Overview", " Chapter 2 Overview As you start to explore building your own packages, it’s a good idea to first think about packages you’ve already used and what you like or dislike about them. This can be helpful in guiding your thinking as you start writing your own packages, helping to make them as useful as possible to both you and others who may use your packages! For example, think of the R package googlesheets from Jenny Bryan. Let’s discuss why this is such a wonderful and widely-used package. First, the name of the package makes it clear what the package is used for! The googlesheets R package makes working with Google Sheets in R a lot easier! That’s a great start. Second, the main functions within that package all begin with gs_. This means that whenever you see gs_ in someone else’s code or whenever you’re trying to remember what function from googlesheets you need, you know that it will likely start with gs_, making it easier to use. Third, the package is well-documented and has vignettes. We’ll discuss these in later lessons in this course, but for now what this means is that if you are trying to figure out what a function does, how to get started, or how to use the package overall, a look at the package’s vignettes, peak through the package documentation, or a quick Google search will usually solve your problem quickly and painlessly.  While we’ll get to discussing function naming, documentation, and vignettes in coming lessons, we’ll focus on the first point here - package naming! We’ll also discuss the basic components of an R package and get you on your way to creating your first R package. 2.0.1 Package Naming Technically, your package name can be anything, so long as it (1) starts with a letter, (2) only contains letters, numbers, and periods, and (3) does not end with a period. But, when it comes to naming a package well there are a few additional things to keep in mind. If your package is just for your use, you can name it whatever you want. But, if you have any plans of releasing your package, there are a number of guidelines to follow. And, whether you plan on releasing it or not, it’s probably best to just get in the habit of following these guidelines. Your package name should: make it clear what your package does not be the name of an already-existing R package all be lowercase be as concise as possible For example, stringr is a package that makes it easy to work with strings. ‘string’ is right there in the name and the r at the end indicates that it’s an R package. Similarly, lubridate makes it easier to work with dates and sounds like the word ‘lubricate’ - a great name for that R package. Moving beyond the most obvious cases, dplyr may seem like an odd name for a package, but this package works best for dataframes (the ‘d’ in dplyr), generalizes the “apply” family of functions (the ‘ply’), and uses pliers (‘plyr’). As you start writing your own packages, it’s best to spend some time thinking of a good name at the beginning of the process and are sure that an R package by the same name does not already exist 2.0.2 The Minimal Package Packages do not have to be anywhere near as complex as those that we’ve mentioned so far. Your package does not have to make working with Google Sheets easier, work out how to work with strings/dates, or allow for piping to be a worthwhile package. In fact, you can create an R package with a single function, stored in the R/ directory and a text file called DESCRIPTION. This is an example of the bare bones needed to create an R package. In this and the following two two lessons in this course we’ll work on building a minimal (yet functional!) R package. 2.0.3 A Strong Package However, in order for a package to be useful, a package should have a few additional components. This makes understanding the code/functions in your package and overall usage of your package easily understood by you in the future as well as others trying to use your package. Strong Packages also have: tests - code that runs each time your package is built to check to ensure that the behavior of each of your package’s functions are behaving as expected good documentation - descriptions of each function, the inputs (arguments) it takes, the outputs it returns, and examples of how to use it vignettes - guides and examples demonstrating how to use the functionality of your package In the final lessons in this course, we’ll dedicate time to writing a good R package with proper documentation and tests. 2.0.4 Package Types Before we jump into creating your first R package, let’s take a second to lay out the types of packages that exist. Generally, there are five states of an R package: source bundled binary installed in memory As you use R packages, it’s typically not important to know or even think about which state your package is currently in. However, as you start to develop R packages and need to debug your packages, understanding these states can help you debug more quickly. 2.0.4.1 Source Packages Source Packages are those packages you’re developing on your computer. It’s a bunch of functions stored in an R/ directory along with a DESCRIPTION text file. As we create your R package in this course, add functions, and edit documentation, we’ll be working with the source package. 2.0.4.2 Bundled Packages Bundled packages are those where all components of the package have been compressed into a single file (usually with the extension tar.gz). You will typically not encounter or work with bundled packages - they are used to move between other states. 2.0.4.3 Binary Packages Like bundled packages, binary packages are also a single, compressed file. However, when decompressed, bundled packages have a structure very similar to source packages - or what’s on your computer. Binary packages, on the other hand, have a very different internal structure. For example, functions are not stored in .R files in the R/ directory as they are in source packages. What’s important to know about binary packages is that they are platform-specific. This means that someone who has a Windows laptop will need a different binary package (a file that ends in .zip) than a Mac user (who would need a file that ends in .tgz). 2.0.4.4 Installed Packages Installed packages are binary packages that have been decompressed into a package library (we’ll talk about these in just a second!). Packages can be installed in a number of ways. For example, we’ve discussed that for packages on CRAN, you can use install.packages(). What this does is take the binary package stored on CRAN that is appropriate for the Computer platform you’re using, downloads the binary package to your computer, decompresses it, and stores that in your package library. However, to install a package from GitHub, we’ve noted that you can use devtools::install_github(). This takes the source package on GitHub, bundles it into a bundled package, decompresses that file and then installs the package into your package library. While it’s not super important to understand the details of each state a package can be in, it’s important to be at least aware, as you will run into different package states along the way. 2.0.4.5 In-Memory Packages We’ve discussed previously that there is a difference between installing and loading a package. To use the functions within a package, it first has to be installed. This is done most typically with either install.packages() or install_github() from devtools. After installation, however, you can’t actually use the functions until you load the package into memory (our final package state!). So far we’ve used library() to load the package into package. This loads the package when you use library(), making its functionality available to you. Something we haven’t discussed in detail yet, however, is that you can use a function without loading the entire package into memory by calling the package and function name separated by two colons. For example, if you haven’t loaded devtools into memory but want to use install_github() from devtools you can call devtools::install_github() to use that function. We’ll use this format frequently throughout package development. We’ll avoid using library() in package development, as it requires the package be installed before being able to use the package’s functions. Instead, we’ll use the package::function() format frequently in package development. 2.0.5 A note on library() As discussed in the Introduction to R course, packages you’ve installed are stored in your package library. The function .libPaths() will tell you where on your computer your installed packages are stored. Whenever you call library() on package, R will look in this path for a directory with the specified package’s name and load that package into memory. 2.0.6 Getting Started: Your First R Package RStudio has a bunch of built-in functionality to help make package development simpler, and you can take advantage of this functionality on RStudio Cloud. In fact getting started building your first R package requires just a few steps! We suggest you follow along as the following lessons in this course will refer back to the skeleton package we create in this lesson. 2.0.6.1 Step 1: Create New Project on RStudio Cloud As you’ve done previously, you’ll start by going to Rstudio Cloud and creating a new project.  We’re going to create a package called cbds, so you can should this project ‘cbds’. Now, we talked previously about how having a good name for your package is important. Because this is just a package being created as an example, cbds is a fine name. But, if it were a package being used for a specific purpose or one to be released out into the world, you should spend more time and think of a better name for sure!  2.0.6.2 Step 2: Install usethis Up to this point, this should all be pretty familiar. However, now we get into the fun stuff! As with most things in R, there’s a package called usethis for helping people develop packages! As described on their website, usethis “is a workflow package: it automates repetitive tasks that arise during project setup and development, both for R packages and non-package projects.” Sounds like just the thing we want! To get starting using usethis, we’ll have to first install it! # install package install.packages(&quot;usethis&quot;) 2.0.6.3 Step 3: Create Package Now, you’re ready to create your first package. To do this we’ll load usethis into memory and then use the create_package() function to create our project that will store the source package! # load package library(usethis) # Create a new package create_package(&quot;cbds&quot;) When you run this code, you’ll get a warning message asking you if you want to create the package anyway. Choose the numeric option (here, it’s 3) that corresponds to “Yup”.  You’ll then be prompted to see if you want to Switch Projects.  Click Save when asked if you want to Save workspace image to /cloud/project/.RData and you’ll be moved into the directory cbds/.  Notice that you’re now within /cloud/project/cbds and that a number of files are visible here. These have all been created for you thanks to the create_package() function from usethis. Earlier we mentioned that a minimal package has a folder called R/ and a text file called DESCRIPTION. Both of those have been created for you! This means that you have a minimal package already…in just a few short steps! 2.0.6.3.1 Aside: RStudio Project Files The reason we get this message asking us if we want to create a project within an existing project while telling us this is generally not a good idea has to do with the fact that we’re building this on RStudio Cloud, rather than RStudio on our local computer. Something we haven’t discussed a ton up to this point is that everything on RStudio Cloud is organized into projects.Within each project a project.Rproj file is created. .Rproj files are text files that keep track of information about your project. Packages also require an .Rproj file within the package directory. Because RStudio Cloud already has a .Rproj file by default for the project space, we see this message.  2.0.6.4 Step 4: Build Package You should also notice on RStudio Cloud that a “Build” tab is now visible at the top-right. If you click on “Install and Restart”, RStudio will build your package from the source package files in this directory, restart R in the console, and load your package into R. A log of what’s happening will also be kept in the Build tab.  Here, you’ve built your package from the source package files in this directory; however, we haven’t actually added any functions to this package yet. That’s what we’ll do in a coming lesson. Once we do that, we’ll build the package and test out its functionality! 2.0.7 Summary In this lesson we’ve covered package naming, what is required for the minimal R package, what’s needed to make a good R package, and got started creating our R package using the usethis package. In coming lessons we’ll add functionality, documentation, tests, and vignettes to our package as you get more and more comfortable using RStudio Cloud for package development! 2.0.8 Additional Resources The minimal R package, by Karl Broman usethis documentation, by Jenny Bryan and Hadley Wickham Writing R Extensions, from the R Core Team 2.0.9 Slides and Video Overview Slides "],["functions.html", "Chapter 3 Functions", " Chapter 3 Functions Functions were first introduced in the Introduction to R course in the Cloud-Based Data Science Course Set. If you’d like a review before this lesson, please refer back to the functions lesson in that course. We review functions here as they are the operational unit of packages. As you continue to add functionality to the cbds package skeleton we created in the previous lesson, you’ll need to be comfortable with writing functions. 3.0.1 Functions: Review Functions help make your code more modular. This means that instead of having a single file with all of your code running as a script from top to bottom, you can instead write user-defined functions for processes that you’ll do over and over again.  For example, if you are working with multiple, similar datasets and have to carry out the same operations on each dataset, rather than copying and pasting the code to do so and changing the DataFrame you’re operating on, instead, you can write a single function, including the necessary code and then execute that function on each dataset. In doing this, you accomplish a few things: You make your code more readable. Code is read more often than it is written. By having a single function, readers of your code only have to understand that code block once. When they encounter its use, they already know what the code will do. And, it will lead to less code overall to read. It simplifies updating your code. If you have the code in a single function and then use that function throughout, if a change needs to happen, you have to only change it in a single location, rather than looking for all the places you’ve copy and pasted the code. If you find yourself copy and pasting code more than once, write a function. You avoid accidental errors. If you’re using related and very similar code in multiple places rather than writing functions, you have to remember where you copy and pasted and how many places you’ve done so. With functions, you have a single copy and only have to update that, minimizing the chance of errors and forgetting to edit your code in more than one place. 3.0.1.1 When To Write Hopefully, if you’re at the point in your learning that you’re ready to start writing packages, you’ve gotten more comfortable with using functions from others’ packages and are getting more comfortable with writing your own functions. Packages are built around writing functions, so you’ll get extra practice in this lesson and hopefully by the end of this course, it’ll be close to second nature. When writing packages, you’ll write a lot of functions. The general rule is that you should write a function whenever you’ve copy and pasted code more than once. However, in packages, functions are the operational unit - the thing that we’re going to be building a package upon, so we’ll be thinking about building our packages with a function-first mentality!  3.0.1.2 How To Write As a reminder, there are three main components to a function. Each function has a: name argument(s) body In code, in its most simple form, defining a function looks as follows: name &lt;- function(arguments){ body } As discussed in the Introduction to R course, naming your function is an important step. So important, that we’ll review it here. In almost every case, function names should be verbs - or action words. This makes sense as functions do things; they carry out actions. (On the other hand, variable names tend to be nouns, as they represent objects or things.) Function names should: be verbs explain what the function does be succinct use snake case (i.e. make_snake_case() could be a function that takes a string as an input and coverts the string to snake case, where all words are lowercase and separated by underscores) not have a name used elsewhere (i.e. don’t use mutate() as that’s used in dplyr) 3.0.2 Function Example: Temperature In the Introduction to R course, we provided an example function of converting an input temperature in Celsius to Fahrenheit: celsius_to_fahrenheit &lt;- function(){ C &lt;- readline(prompt=&quot;Enter a value in Celsius: &quot;) F &lt;- as.integer(C) * (9/5) + 32 return(paste(&quot;The entered Celsius temperature is&quot;, F, &quot;degrees Fahrenheit.&quot;)) } Note that this code simply creates and defines the function. To actually use the function to convert degrees Celsius to Fahrenheit, you have to execute the function: &gt; celsius_to_fahrenheit() Enter a value in Celsius: 70 [1] &quot;The entered Celsius temperature is 158 degrees Fahrenheit.&quot; We also discussed previously that this function could be generalized to convert in both directions (to Celsius or to Fahrenheit) by utilizing additional arguments. To make the function clearer, we’ve also included comments: convert_temp &lt;- function(temp, unit = &quot;C&quot;){ if (unit==&quot;C&quot;){ # if temp in C, convert to F D &lt;- temp * (9/5) + 32 } else if (unit==&quot;F&quot;) { # if temp in F, convert to C D &lt;- (temp - 32) * (5/9) } else { D &lt;- message(&quot;Please enter a correct unit -- either F or C&quot;) } return(D) } 3.0.3 Function Example: Even vs. Odd Sometimes the best way to understand a topic is to familiarize yourself with multiple examples. We’ll walk through two more function examples, explaining each part along the way. These are not functions we’ll include in the package we’re building in this course and are instead just meant to help you gain a deeper understanding of writing functions in R. Here, we’ll be building a function that determines whether or not an input value is even or odd. Something you may be less familiar with at this point is the modulo operator: %%. This operator divides the number on the left hand side of the operator with that on the right-hand side and returns the remainder. For example if you do the following mathematically: 7 / 3 in R, you would see that 7 divided by 3 is 2.3333. This is because 3 goes into 7 twice, with one remainder. If you’re interested in only returning that 1 remainder, you would use the modulo operator. So, in R, 7 %% 3 returns 1 - the remainder of 7 divided by 3! This operator can be helpful in many situations, one of which is determining whether a number is even or odd. For example, if a value divided by 2 returns a remainder of zero, you know that number is even! Let’s write a function to do just that! ## generate the function even_odd &lt;- function(value){ if (value %% 2 == 0){ print(&quot;even&quot;) }else{ print(&quot;odd&quot;) } } Here, we see that the function’s name is even_odd and that it takes one input parameter (value). So if we created this function by running the code you see above, you would then be able to execute the function by calling the function name and providing an input variable: ## execute the function even_odd(6) even_odd(17) When we execute the two lines of code here we see that when 6 is the input argument, the function correctly returns “even”. When 17 - and odd number - is the input argument, the function correctly returns “odd”. Naming the arguments As a reminder, R knows that you’re specifying the input value even though you haven’t explicitly stated that this is the value argument. To be more explicit and make your code even more readable, it can be helpful to explicitly state the argument’s name in the function call. The code here is functionally the same as the code previously; however, we’ve added value = to be clear what argument we’re inputting to our function. ## naming the argument even_odd(value = 6) even_odd(value = 17) 3.0.3.1 Adding warnings Something we haven’t talked about previously is checking that the inputs to your functions are what it was expecting. For example, our function for checking even vs. odd numbers works great if we give it a number. What happens if we accidentally give it a string, where checking even vs. odd does not make sense? ## will produce an error even_odd(&#39;cbds&#39;) In this example, we get the error: “Error in value%%2 : non-numeric argument to binary operator” This is because it doesn’t make sense to try to calculate the remainder of a string divided by 2. It is often the case in functions that you only want to operate on a certain type of input. When this is the case, it’s best to check that the input to your function is what you expected. One way to do something like this is to add a warning message, using the warning() function: even_odd &lt;- function(value){ # add warning message if(!is.numeric(value)){ warning(&quot;Input value is not numeric.&quot;) } if (value %% 2 == 0){ print(&quot;even&quot;) }else{ print(&quot;odd&quot;) } } For example, when we create the function here, we add an if statement at the top of the function to check if the input to value is not numeric and if it is not numeric print a warning that the “Input value is not numeric”. However, one caveat to this is that a warning doesn’t stop the code from running. It will still attempt to run the function with this input. So, if you try to execute this function without a numeric input (for example running even_odd('cbds')), you’ll see the warning; however, you’ll still also get an error message. 3.0.3.2 Adding stop If we replace warning() with stop(), the function will not execute past where stop() is encountered. This way, the user (you, in this case) only sees the specified error message. even_odd &lt;- function(value){ # stop if non-numeric if(!is.numeric(value)){ stop(&quot;Input value is not numeric.&quot;) } if (value %% 2 == 0){ print(&quot;even&quot;) }else{ print(&quot;odd&quot;) } } Using this function, when we then run even_odd('cbds'), the only thing returned is “Error in even_odd(”cbds”) : Input value is not numeric.” Note that what is returned from the function with a numeric input variable is still what we expect. even_odd(6) still returns “even”. It’s good practice to add checks using warning() and stop() to ensure your functions are behaving as you expected them to when you wrote them. 3.0.4 Function Example: Exponentiation For another example, let’s consider the case of exponentiation. In math you can exponentiate numbers. For example, 6 to the power 2 (6^2) means take the number 6 and multiply it by itself (6 * 6). 6 to the power 3 (6^3) says take 6 and then multiply itself again (6 * 6 * 6). This idea of exponentiation is very helpful, so it can be helpful to have a function that does this for you: exponentiate &lt;- function(number, exponent){ out &lt;- number ^ exponent return(out) } Here, we’ve generated a function called exponentiate that takes two parameters (number, exponent). Within the function, we see that the number is raised to the power exponent. This value is then stored in the variable out. This variable out is then returned from the function. For example, after defining this function, we could execute it by running exponentiate(6,2) and it would return the value “36”. We could also be clearer about our arguments and run exponentiate(number = 6, exponent = 2). This would also return “36”. Default Parameters However, we could improve this function taking things one step further by specifying a default argument. In the case of exponentiation, it’s most comment to raise something to the power 2. So, we may want to set the default argument for exponent to be 2. We do this within the arguments of function(). When we do this, if no value is provided when the exponentiate() function is executed, then R will use the default value 2. exponentiate &lt;- function(number, exponent = 2){ out &lt;- number ^ exponent return(out) } For example, if we created this function and then ran exponentiate(6) or exponentiate(number = 6), R would return “36”, as it knew to use the number 2 as the value for the exponent argument. However, we aren’t locked into using 2 as the only possible value for exponentiation. If we call the function, we can specify a different value for this argument. exponentiate(6, 3) or exponentiate(number = 6, exponent = 3) would raise 6 to the power 3, returning the value “216”. Setting default values for arguments within functions can be very helpful and save you time. 3.0.5 Summary In this lesson, we’ve reminded you of the basics of writing functions in R and walked through a few additional examples; however, we’ll be creating a package throughout this course and writing more functions. If you’d like more information and practice than provided in this lesson before moving on to creating a package in this course, check on the additional resources below. 3.0.6 Additional Resources Chapter 19: Functions in r4ds, by Hadley Wickham in R for Data Science Functions, by Hadley Wickham in Advanced R Writing Functions and Functions, blog posts from Nice R Code 3.0.7 Slides and Video Functions Slides "],["code.html", "Chapter 4 Code", " Chapter 4 Code In the previous lessons in this course so far we’ve discussed R packages in general, reviewed functions and got a minimal R packages started using create_package() from the usethis package. This means that we’re now ready to start adding functionality to our cbds package! Earlier, we mentioned that a minimal package has a DESCRIPTION file and functions stored in .R files within the R/ directory. It’s those functions that we’re going to write now and store in .R files within the R/ directory. We’ll get to the DESCRIPTION file shortly. 4.0.1 Adding Functions Functions are defined within your R package using the function() function, just as we discussed in the previous lesson. We’ve also discussed that picking good names for functions is important. And, we’ve mentioned that these functions are stored in .R files within the R/ directory. What we haven’t yet discussed yet is how many functions go in each .R file? Well, technically, it’s up to you. You could store every single function in a single .R file, stick it in your packages R/ directory and call it a day. However, that is likely not the best organization. With everything in a single file, it’s hard for you or others reading your code to know where to look for certain functions. And, it’s more difficult to document (which we’ll get to later). So, for now, we’re going to recommend that each function be stored in its own .R file. In this course we’re going to add two functions to our package, which means we’ll have two .R files…one for each function. We’ll choose to name these files to match the names of the functions stored within. This is not required, but it makes your life easier. As packages grow to have additional functionality, however, sometimes you’ll write small “helper” functions that don’t need much documentation. These can be stored in a single file. We recommend that until you are comfortable with package development, you err on the side of more files rather than all functions in a single file. The package we’re developing here is meant to make your life easier. It’s a package that will contain functionality for tasks you may find yourself doing over and over again - such as checking for missing data or changing the theme on your plots. Rather than writing the code to do this from scratch each time, we’ll add functions to our package so that all you have to do is load your package into your R session and you’ll be ready to go. Many people have packages for their own personal use, including Karl Broman and David Robinson. Feel free to check out those links to see what others include in their personal packages. In the personal package we build in this course we’re going to add two functions for tasks we may find ourselves doing frequently: checking for missing data within a variable in a dataframe changing the ggplot2 theme 4.0.2 Function Names As discussed previously, using snake case (lower case with words separated by underscores) and verbs (action words) is a great place to start when naming functions. We also want them to be concise. So, for checking for missing data, let’s go with check_na(), since NA is the designation for missing data in R. Now, for theme, we could use set_theme, but you could imagine that you may want to have different themes in different situations, so let’s use theme_cbds(). It’s not a verb, but it will be a modification of the existing theme() function, so it’s a good name in this situation. Let’s get to writing these functions! 4.0.3 Storing Functions in .R files Once you’ve got your plan and your function names, it’s time to start writing functions in .R files. To do this, you’ll first navigate to “File” &gt; “New File” &gt; “R Script” to create a new R Script.  A new untitled R script will show up in the top-left hand pane.  We’ll want to save this file with a helpful file name before including any code in this file. To do so, got to “File” &gt; “Save As…”  The Save File window that pops up is where you will type in your file name. Here, we’ll save the first file as check_na.R. Note that this file is being stored in /cloud/project/cbds/R. We’ve mentioned previously that your package’s functions should all be stored in the R/ directory within your package. Be sure that the path to where these files should be saved is correct. Once you’ve typed in the filename, click “Save”  Repeat this process to create a second .R file called theme_cbds.R. You should now have two files open in the top-left hand pane. And, if you click on the R/ directory in the Files tab at the bottom-right, you should see these two files stored in that directory. Now, we’re ready to start writing some code! 4.0.4 Function 1: check_na() We’ll start by writing our check_na() function. 4.0.4.1 Skeleton When writing functions, it’s typical to start with the basic function skeleton, including the function name, the function() call and curly braces. Return to check_na.R, and let’s get started with that skeleton: check_na &lt;- function(){ } 4.0.4.2 Inputs &amp; Outputs We haven’t discussed in detail yet exactly how we want this function to work, but I find myself frequently wanting to know how many NAs there are in a column in a dataframe. We could write a function to summarize the entire dataframe (as has been done in the skimr and naniar packages discussed in previous lectures), but let’s just start simple. If we give the function a column of information as an input, can the function return the following three pieces of information: number of observations number of missing observations number of non-missing observations This means that the input will be information that could be stored in a column from a dataframe. The output will be a summary of the three pieces of information above. With that plan in mind, we can start building our function. Here, we’ve provided variable as the single input into the function we’re writing we specified that we need and have included a few comments to help us plan what code we’ll need to write within our function. check_na &lt;- function(variable){ # calculate number of observations # calculate number of missing observations # nonmissing = total = missing # return summary } Now we can start to fill in our function with code that accomplishes the plan we’ve laid out with comments: check_na &lt;- function(variable){ # calculate number of observations obs &lt;- length(variable) # calculate number of missing observations nas &lt;- sum(is.na(variable)) # nonmissing = total = missing non_na &lt;- obs - nas # return summary out &lt;- cbind(obs, nas, non_na) colnames(out) &lt;- c(&quot;N&quot;, &quot;NAs&quot;, &quot;Non-NAs&quot;) return(out) }  Remember that defining a function just creates the function. It does not execute the function. To execute this function, we would want to save the file check_na.R, then click “Install and Restart”in the Build top at the top right-hand portion of RStudio Cloud. Remember, this rebuilds your package, so the check_na() function is now available to you when your package is loaded into memory (using library(cbds), which executes when you click “Install and Restart”).  Now you can test out the functionality of your package’s first function! Let’s first test it on a column from the iris dataset. We’ve seen this dataset before, and it includes information about different iris flowers.  Remember: To execute a function you call the function’s name and then provide the necessary inputs within the parentheses: check_na(iris$Sepal.Length)  Note in the output we see that there are 150 observations and no missing data. Let’s make sure that this works for data where there is missing information. We’ve worked with the msleep (mammalian sleep) dataset previously from ggplot2. You may recall that the variable sleep_rem from that dataset had missing information. So, let’s test out our function on that variable: library(ggplot2) check_na(msleep$sleep_rem)  Perfect! Our function correctly calculates that there are 22 missing values in this variable! When we test out our functions in the console like this, we’re doing what are called smoke tests. We’re checking quickly to ensure that our function works. However, there are more formal tests called unit tests that we’re going to discuss in the next lesson. So, keep this idea of testing out the functions within your package in the back of your mind for now and we’ll discuss formal testing in the next lesson! And, just like that, we’ve accomplished our first goal! We’ve got our first function in our cbds package! Now for our second function! 4.0.5 Function 2: theme_cbds() Often we want to customize our plots to look a certain way. We want to change the default settings in ggplot2 to better fit the look we’re going for in our project. However, it’s often that we’re working on a project and we want that look to apply across all of our plots in the project we’re working on. This leads us to want a function that will change the theme across all plots in a project. We can write a function to accomplish this! In fact, others have already done this! We’re going to be modifying code from Karl Broman’s personal R package to accomplish this for our needs. In our Data Visualization course, we discussed a number of best practices in data visualization. One general theme we’ll focus on here is that each bit of ink on the plot should serve a purpose. For example, the gray background that we have by default in ggplot2 doesn’t really serve a purpose, so in our theme_cbds() we’ll get rid of it. We’ll also make it easy to change the font and to increase or decrease the font size on our plots within this theme. For anything that you want to change from one plot to the next, you’ll have to include it as an argument (input) to your function. The two things we want to be able to change are the font size (base_size) and font (base_family). The third argument you see here is just three dots .... This is officially known as an ellipsis. theme_cbds &lt;- function(base_size = 12, base_family = &quot;&quot;, ...) { } 4.0.5.1 Aside: ellipsis In R (and other programming languages), the ellipsis (...) allows functions to take any number of named or unnamed arguments. While this may seem a bit confusing, there are really only two cases where you would want to use this: When your function calls other functions within it, and these functions can take additional arguments. This allows you to pass arguments into your function that will then be applied to the functions you use within your function. When you need your function to be able to take a variable number of arguments. Here, we’ll see a case of Situation #1. With our skeleton function established, now it’s time to figure out exactly what it is we want the aesthetic of our cbds plots to be. Generally we’ll want: a white background only the left and bottom axes to be present axis tick labels to be close to their axes grid lines removed A lot of this (white background, left and bottom axes present, and grid lines removed) can be accomplished by setting the theme to theme_classic(), where we pass the input parameters of our function as inputs to that function. However, to move the axis text labels closer, we’ll need to modify theme() directly. Our general approach will be as follows: theme_cbds &lt;- function(base_size = 12, base_family = &quot;&quot;, ...){ # change to theme_classic # move axis ticks closer to axes } Now it’s just time to fill in the code. From ggplot2’s documentation, we learn that we can use %+replace% to modify elements in a theme. Additionally, you’ll note that we’re using ggplot2:: any time we want to call a function from the ggplot2 package. This is a best practice when writing functions within a package. You’ll want to explicitly call the package name and the function you want to use, separated by two colons (::) any time you call another package’s function. Finally, you’ll see that the ellipses is called within ggplot2::theme(). This means that if you were to pass additional arguments into your theme_cbds() function call, they would be applied to change additional aspects of the plot’s theme(). theme_cbds &lt;- function(base_size = 12, base_family = &quot;&quot;, ...){ ggplot2::&quot;%+replace%&quot;( # change to theme_classic ggplot2::theme_classic(base_size = base_size, base_family = base_family), # move axis ticks closer to axes ggplot2::theme(axis.ticks.length = grid::unit(0, &quot;cm&quot;), ...) ) }  Just as with the first function example, we have to test out to make sure this function is behaving as we expect it to! Time for a few quick smoke tests. After clicking “Install and Restart” in the Build tab, we can then test this function out on the iris dataset. First, let’s remind ourselves what the ggplot2 defaults look like: Note that if you’re testing this out on a space where ggplot2 has not been installed, you may have to uncomment and run the first line below: # install.packages(&quot;ggplot2&quot;) library(ggplot2) # generate default plot ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) + geom_point()  Now, let’s utilize our new function from our package to improve this plot’s aesthetics! # use cbds theme ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) + geom_point() + theme_cbds()  That looks pretty great! A lot cleaner plot now that we’ve applied our modified theme to it! But, don’t forget that we have two inputs to our theme that we want to ensure are behaving as expected. So, let’s generate the same plot but change the font and increase the font size by passing this information in as arguments to our function. # use cbds theme # change font and font size ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) + geom_point() + theme_cbds(base_size = 18, base_family = &quot;serif&quot;)  Looks like our package with two functions is working as expected! We’ve got a different font and a larger font size for the text. 4.0.6 Summary At this point, we have a pretty minimal package - it does have two functions in it, but it is missing documentation and vignettes. And, we haven’t yet discussed the DESCRIPTION file. So, feel free to add any additional functions you may want to have in your package at this time. And then let’s continue on to the following lessons to take this package from a minimal package to a strong and well-documented package! 4.0.7 Additional Resources testthat, by Hadley Wickham R Packages - R Code, by Hadley Wickham and Jenny Bryan 4.0.8 Slides and Video Code Slides "],["testing.html", "Chapter 5 Testing", " Chapter 5 Testing 5.0.1 Code Testing In the last lesson, we added two functions to our cbds R package. To see that they were working as we expected, we ran the functions on data and looked to see if we got the expected outcome. We mentioned that these are known as smoke tests. They’re quick checks that you run to make sure your code is doing what you expect it to do. When people write code in R, they almost always run these types of tests. However, what is less common among R programmers, is writing tests that automate your tests. When automated, the tests are written and ready to run so that any time changes are made to your package, you run these tests to ensure that you’re not getting any errors. It’s this type of testing we’ll cover in this lesson. By the end of this lesson you’ll have written tests for the two functions in our cbds package and be familiar with how to automatically run these tests during package development. 5.0.2 Unit Tests Writing unit tests moves your code from only writing smoke tests to be able to save your tests and automate package testing. While it may take a little bit of work up front to get used to programming like this, it will ultimately save you a ton of time in the following ways: Fewer errors - When you write tests explicitly for each aspect of your code, you’re automatically checking to ensure that each piece is behaving as expected. When you change code within your package during development, these tests will identify whether or not behavior as broken automatically, cluing you into bugs in your code much earlier than if you didn’t have the tests. Note that when you find a bug in your code, you should get in the habit of writing a unit test right then and there. This way, you never have to fix a bug more than once! Quickly identify bugs - when a well-written unit test fails, you know precisely where to look in your code to identify the issue. You won’t have to go back through all of the code in your package to track down what’s gone wrong. Better code - Code that is easily tested tends to be better code. In writing tests, you’re forced to simplify your code into functions that carry out a single task (rather than having a large function that does a whole bunch of different things). In this process, your code will be easier to read and better designed overall. Unit tests are meant to be small tests, each of which tests a different piece of your overall code (here, your package). So, for each “thing” that your package accomplishes, you’ll want to be sure to have at least one unit test. Note that there are additional tests that are helpful within software development (including integration tests and system tests); however, unit tests are the fundamental unit, the first piece in the puzzle, and the most important piece to master when writing R packages, so we’ll focus on those here. 5.0.3 testthat As with writing packages, where usethis was a helpful package for automatically getting the structure of your package set up, testthat is a package written by Hadley Wickham to help R programmers write unit tests and automatically test the functionality within their packages. To use this package, you’ll first have to install it from CRAN: # Install from CRAN install.packages(&quot;testthat&quot;) 5.0.3.1 Creating a test file Once you have testthat installed, you can use use_test() from usethis to set up the required directories and files needed to start running tests. The input to this function should be the name you want to use for your test file. In our case, we’re going to write tests for the check_na function, so we’ll use that as the input. This function will then create (and open!) a file for us with the word test- followed by the name we specified. # create test and structure usethis::use_test(&quot;check_na&quot;)  Executing this function also creates a tests/ directory within our package. Within that directory there will be a directory called testthat/. The test file we just created test-check_na.R will be stored within that directory. There will be example code within that file. This is where we’ll write our unit test code. Finally, within tests/ there will be a file called testthat.R. This file automatically has code within it that will allow for automated testing to take place.  5.0.3.2 Testing Expectations Within the file that was created for you using use_test(), you’ll see an example unit tests: test_that(“multiplication works”, { expect_equal(2 * 2, 4) }) There are two parts of the test_that() example. test name - a brief description of the test (i.e. “multiplication works”) code - the test containing the expectation (`expect_equal(2 * 2, 4)) The test name should be descriptive, informative, and short. Good descriptions will help you later on quickly identify any issues. In this example, the code within the test is checking to see whether or not (2 * 2, what’s on the left hand side of the comma) is equal to 4 (what’s on the right hand side of the comma). As 2 * 2 is equal to 4, this test would pass. All tests should be written so that they pass. If a test does not pass, it will throw an error. This is how unit testing works! All tests that test code that is doing as we expect should pass silently. However, if an error is encountered, testing will throw an error. Now, testing that two things are equal, using expect_equal(), is not the only way you can test code; however, it is a very common type of test. There are other expectations that you can use, but all of them evaluate as either TRUE or FALSE. Tests that pass evaluate as TRUE. Tests that fail evaluate as FALSE. As we saw above with the expect_equal() multiplication works example, expectations have the following structure: They start with expect_ They take two arguments: the first is the result of the test, the second is the expectation If the actual and the expected results fail to agree, you’ll get an error. There are many different types of expectations, but the most commonly used are described here: 5.0.3.2.1 expect_equal() As described above, expect_equal() tests that the statement passed as the first argument is equal to the second argument. For example, the following statement would pass silently as 2 is in fact equal to 2: # passes silently expect_equal(2, 2) However, the following would throw an error, as 2 is not equal to 1: # throws an error expect_equal(2, 1) 5.0.3.2.2 expect_match() expect_match() tests a character vector and determines if it matches with the stated regular expression. Note: We discussed regular expression briefly in the Working with Strings lesson of the Data Tidying course, so feel free to review that lesson before moving forward here. For example, the following statement would pass silently as “love” is within the test_string: test_string &lt;- &quot;I love CBDS!&quot; # passes silently expect_match(test_string, &quot;love&quot;) However, the following would throw an error, as “LOVE” is not within the test_string, due to case-sensitivity: # throws an error expect_match(test_string, &quot;LOVE&quot;) 5.0.3.2.3 expect_message(), expect_warning(), &amp; expect_error() These three expectations check at their simplest whether or not a message, warning, or error is generated. For example if you tried to divide a number by a character string: 1/\"cbds\", you would get the error: “Error in 1/”cbds” : non-numeric argument to binary operator” Therefore, if you’re expecting an error, the following would produce an error and therefore pass silently: # passes silently expect_error(1/&quot;cbds&quot;) However, it’s best to include explicitly what the message, warning, or error you’re expecting is. # explicit error provided expect_error(1/&quot;cbds&quot;, &quot;non-numeric argument&quot;) Note that if you stated the incorrect error message (one that is not produced), you will get an error. # incorrect error message expect_error(1/&quot;cbds&quot;, &quot;NaNs produced&quot;) By providing the error message to expect_error() that you’re anticipating, you’re writing a better test, so that it will only pass silently when the expected error message is produced. 5.0.3.2.4 expect_is() expect_is() checks that the class of the specified object is of the stated class. For example, the following statement would pass silently as “cbds” is of the class “character”: # passes silently expect_is(&quot;cbds&quot;, &quot;character&quot;) However, the following would throw an error, as the string “cbds” is not numeric: # throws an error expect_is(&quot;cbds&quot;, &quot;numeric&quot;) 5.0.3.2.5 expect_true() &amp; expect_false() Finally, if none of the other expect_ functions fit what you need, you can use either of these functions which expect to evaluate as either TRUE or FALSE. However, whenever possible, it’s best to be explicit and use the other expectations already mentioned. 5.0.4 Testing Function #1: check_na() Now that the files have been created and we have some idea of the different types of expectations we can utilize, it’s time to start actually writing unit tests! As we start writing tests, each test should test a single aspect of your package. Note that you can put more than one expectation within a single test. But, avoid putting too many expectations into a single test. When it comes to debugging and tracking down errors, a number of smaller tests is better than a single or a few large tests, for sure. Additionally, you do not have to test every single function within your package. If there are small bits of simple code that you’re sure will work, then you don’t need a test. However, in the beginning, as you get comfortable writing unit tests, it’s good practice to write tests for each major function within your package. Finally, any time you encounter a bug during package development, go write a test. Your future self will thank you. Or rather, your future self won’t waste time re-discovering the same bug. For our package, we’ll write tests for both of the functions we generated. in the previous lesson. 5.0.4.1 Smoke Test Reminders In the previous lesson we checked to see if our function was working by executing our functions and examining the output. These were smoke tests. They checked to ensure the functions were behaving as expected, but they did not accomplish this in an automated way. For example, we checked to see how many NAs there were in the Sepal.Length column of the iris dataset. Similarly, we looked at the output from our check_na() function using the sleep_rep variable from msleep dataset in ggplot2, since we knew there were NAs expected in that dataset. 5.0.4.2 Unit Test Generation To write a unit test, we’ll similarly want to check all expected behavior of our function, but we’ll just want to do so in an automated fashion, using testthat and storing all expectations within the testthat/ directory we previously generated. For this function, we’ll want to test that our function: correctly counts the number of observations in the input correctly returns the number of NAs in the input correctly returns the number of non-NAs in the input returns the information in the expected output This means, that we’ll have at least four expectations for this function. And, I’ll argue here that we’ll have two different tests, one to test the calculations and another to test the information is returned in the expected format. Let’s first write the test that checks the calculations. We’ll delete the example test provided and then first include an example dataset so that we can test the output of the function on something where we confidently know the answer. Then, within the test, we first include the description “NA calculations correct” and then include the code. The code includes a simple example object where we know the expected answer for sure, execute the function storing the output, and then test that all three calculations are occurring as expected in that output: obs &lt;- c(3, 4, &quot;str&quot;, 10, NA, NA, NA) tested = check_na(obs) test_that(&quot;NA calculations correct&quot;, { expect_equal(as.numeric(tested[1,&quot;N&quot;]), 7) expect_equal(as.numeric(tested[1,&quot;NAs&quot;]), 3) expect_equal(as.numeric(tested[1,&quot;Non-NAs&quot;]), 4) }) Now we need the test that checks that the output are being returned in the expected format. Here we’ll want to check that a matrix is being returned and that it has the expected number of rows and columns: test_that(&quot;NA output format&quot;, { expect_is(tested, &quot;matrix&quot;) expect_equal(dim(tested), c(1,3)) }) The example code used and both of these tests will be all be stored in the test-check_na.R file we generated previously.  5.0.4.3 Running tests in a package Now that we have our first two official unit tests, it’s time to test our package. To do so, return to the Build tab in the top-right panel, click on More, and select “Test Package.” This will run all of the tests in tests/testthat.  The results of these tests will be visible in the Build tab. Notice that we have passed all tests! Let’s keep on writing tests for our package!  5.0.5 Testing Function #2: theme_cbds() Our second function is slightly harder to write tests for as we’re dealing with plotting. However, we can still write effective unit tests for theme_cbds. In the last lesson, we ran smoke tests to ensure that our plots looked as we expected. We wanted to see that our plots had: a white background only the left and bottom axes visible axis tick labels to be close to their axes grid lines removed While slightly more convoluted, we can write unit tests to check all of this expected behavior of our theme. To do this, let’s again use use_test() to create our test files within the expected structure. But, this time, we’ll create a file for the theme_cbds function! # create test files usethis::use_test(&quot;theme_cbds&quot;)  This generates a new file in tests/testthat called test-theme_cbds.R. We’ll delete the example code in that file and replace it with a test that tests our functions expected behaviors: # generate test plot p &lt;- ggplot2::ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) + geom_point() + theme_cbds() test_that(&quot;plot theme defaults&quot;, { expect_equal(as.character(p$theme$axis.ticks.length), &quot;0cm&quot;) expect_is(p$theme$panel.grid.major, &quot;element_blank&quot;) expect_equal(p$theme$panel.background$fill, &quot;white&quot;) expect_equal(p$theme$axis.line$colour, &quot;black&quot;) }) Here, it takes understanding that information about the theme is stored in the theme argument. Then, we have to know what we’ve set the values for each of these theme elements to be in the theme_cbds that we specified. However, remember that the theme_cbds() function also took two input parameters. We want to be sure we’re testing that those are working correctly. So, we’ll add another test into that same file. p2 &lt;- ggplot2::ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) + geom_point() + theme_cbds(base_size = 18, base_family = &quot;serif&quot;) test_that(&quot;font and font size&quot;, { expect_equal(p2$theme$text$family, &quot;serif&quot;) expect_equal(p2$theme$text$size, 18) }) Here, we’re testing to ensure that when we change the base_size and base_family, the resulting plot reflects those changes. We save all of this test code in test-theme_cbds.R.  With these tests written, we save the file, return to the Build Tab, again select More and then click check package from the drop-down menu. You should again get a message that all tests passed!  5.0.6 Test Errors So far we’ve only demonstrated what it looks like when a test passes. But, what happens if a unit test fails? For example, what if into that last test, I had misspecified what font to expect, calling for “sans” in the plot but then testing for “serif”  In this case, the test would (and should!) fail. The output we would get when testing the package would then provide us with a lot of information! First, in red, we see the description of the test where the failure occurred was in the “font and font size” test. We also see what file this test is in, along with the number of the line of code where the failure occurred (here, line 20). We also get a readout of what the mismatch was, and we can see that the test saw a mismatch between “sans” and “serif”. We also see the overall results, where 10 tests passed and 1 failed. Note that even though the test in line 20 failed, the test in line 21 was still run. All tests are tried, even if one fails earlier in the file. If you’re following along and made this change to see the error, do go back and change “sans” back to “serif” so that you’re tests no longer fail! After testing, feel free to click “Install and Relaunch” to ensure that your package is still building correctly. 5.0.7 Summary In this lesson we didn’t add additional functionality to the package, but we did add automated testing to the functionality we added last lesson! We added this automated testing by writing unit tests via the testthat package. If you added any additional functions to the package, add unit tests for those functions now. Or, add additional unit tests for the functions we’ve included. The quicker you get comfortable with unit testing, the easier package development will become! 5.0.8 Additional Resources testthat, by Hadley Wickham R Packages - Testing, by Hadley Wickham usethis documentation, by Jenny Bryan and Hadley Wickham 5.0.9 Slides and Video Testing Slides "],["description.html", "Chapter 6 Description", " Chapter 6 Description At this point in your package development process, you should have the skeleton of for an R package with two functions and two test files already written. However, in previous lessons we noted that you need functions stored in the R/ directory as well as a DESCRIPTION file. It’s finally time to talk about that file and get it all ready to go! 6.0.1 Metadata The DESCRIPTION file stores metadata for your package. In the most general sense metadata is data that describes other data. Specifically in R package development, metadata refers to what you need in order for your package to run, specifies who can use your package (license), and provides others with information about who wrote and is maintaining the package. 6.0.2 DESCRIPTION The DESCRIPTION file has already been generated for you and its expected structure has been established for you. Now, it’s up to you to change the information in that file to reflect your cbds package. To get started, click on the DESCRIPTION file in the “Files” tab so that it opens up at the top-left.  The DESCRIPTION file contains different information on each line where there is a field and a value (separated by a colon). Values that take up more than one line have be be indented.  We’re going to walk through a number of these fields and describe what information goes in each of them so that you have a complete DESCRIPTION file and all your metadata is complete! 6.0.2.1 Package The first line of the DESCRIPTION file contains the Package field. Notice that this line already contains the name of the package you specified previously. You shouldn’t change anything about this line. Just remember that the format is field: value, so here we see “Package: cbds”. 6.0.2.2 Title &amp; Description Next we get to fill in information about what this package does. We do this in two places: Title - a short (one-line, &lt;65 characters) description of your package. Use Title Case (first letter of each word is capitalized, except for small words like “the” and “of” which remain lowercase) and do not add a period at the end. Description - a longer (1 paragraph) and more detailed explanation of the package. Keep lines limited to 80 characters. Each new line will be indented with four spaces. To get a clear example, let’s take a look at the title and description for a few packages you’re familiar with at this point. For example, the ggplot2 package has the following title and description: Title: “Create Elegant Data Visualizations Using the Grammar of Graphics” Description: A system for ‘declaratively’ creating graphics, based on “The Grammar of Graphics”. You provide the data, tell ‘ggplot2’ how to map variables to aesthetics, what graphical primitives to use, and it takes care of the details. Similarly, the forcats package has the following title and description: Title: Tools for Working with Categorical Variables (Factors) Description: Helpers for reordering factor levels (including moving specified levels to front, ordering by first appearance, reversing, and randomly shuffling), and tools for modifying factor levels (including collapsing rare levels into other, ‘anonymizing’, and manually ‘recoding’). A reminder that you can see the Title and description of packages by loading them into RStudio and then using ?packagename. The package documentation will show up in the Help tab.  Writing a good Title line and Description are very important if you plan on releasing your package - they’re how others know what your package does. For our purposes with this first package we’re developing in this course, they’re less important, as we’re just writing a package containing functions for our own use. Nevertheless, it’s good to practice writing this information in the correct format, so write a Title and Description in your package’s DESCRIPTION file.  6.0.2.3 Version Working our way through the DESCRIPTION file, you’ll see a Version field. We’ll discuss versioning in more detail in the final lesson of this course, but for now, know that as packages are developed and improved over time, the package version changes. Users of your package can decide whether or not they want to use the most recent version of your package or if an older version of your package is what they need. For now we’ll just note that packages in development should start with the version: “0.0.0.9000”, which is the current value in your DESCRIPTION file.  Upon release, the version will contain three numbers, separated by periods. Those numbers correspond to ... For example, 1.0.0 would be the first released version of your package. As you patch the package (make a small change), the patch value would increase, such that the next version may be 1.0.1. We’ll discuss what major, minor, and patch mean in the context of versioning in the final lesson in this course. 6.0.2.4 Author The package’s author (here, you!) must be included in your package’s DESCRIPTION file. This gives you credit for your package, but more importantly let’s others know who to contact if something goes wrong. The format for this field is odd because it includes R code, rather than the plain text used in other fields. This field should look like what you see in the DESCRIPTION file provided, but with your information included: Authors@R: person(given = &quot;Jane&quot;, family = &quot;Doe&quot;, role = c(&quot;aut&quot;, &quot;cre&quot;), email = &quot;janeeverydaydoe@gmail.com&quot;) While you likely know your first (given) name, last (family) name, and email, the “role” field is likely something that’s new and unfamiliar. The roles you see in the example here are “aut” and “cre”. These are three letter codes that refer to who the author (“aut”) and creator (“cre”) of the package are. The four most important roles in package development are: cre : The creator or maintainer. Who to email if you have problems with the package aut : The author(s) - the person (or people!) who have made significant contributions to the functions, code, and ideas within the package ctb : The contributors - people who have made smaller contributions to the package cph : The copyright holder - If someone other than the author (a company, for example) holds the copyright. Often, the creator and the author are the same person, but they don’t have to be. But, every package is required to have at least one author (aut) and one maintainer (cre), even if they are the same person. Be sure to edit your package’s DESCRIPTION file to include your information.  Additionally, note that often in package development for large packages, there can be more than one author. The syntax for this requires that author person() calls be separated by a comma: Authors@R: c( person(given = &quot;Jane&quot;, family = &quot;Doe&quot;, role = c(&quot;aut&quot;, &quot;cre&quot;), email = &quot;janeeverydaydoe@gmail.com&quot;), person(given = &quot;Jack&quot;, family = &quot;Doe&quot;, role = c(&quot;aut&quot;), email = &quot;jackdoe@gmail.com&quot;)) 6.0.2.5 License The License field specifies who can use your package. If you’re not releasing your package, this field is unimportant and can be left as is and ignored. However, if you are releasing your package, this field is critical. There are standard licenses that may people choose to use in their packages (i.e. CC0). If using a standard license, you would include the abbreviation in this field. The CC0 license allows anyone to use your code for any purpose.  Often, you may want to put some restrictions on your code and its use, in which case it’s important to look into other licenses, such as the MIT license or GPL-2. 6.0.2.6 Dependencies While including all of the information we’ve discussed so far is important for others to know what your package does, this section is critically important to make sure your package actually works. In the skeleton provided for your package you’ll see the Suggests field. This is one of a number of different fields that you can use to specify what packages your package relies on to function. In this section of the lesson we’re going to discuss the following fields related to dependencies: Imports, Suggests, and Depends. Imports Packages included in the Imports field are those that are required for your package to function. Packages you include in this field will be installed (if they haven’t been already) any time your package is installed. But, remember, that package installation and making a package available for use are two different steps. So, while this package will be installed, to be used in your package, you’ll have to explicitly refer to the package and function you want to use (using the package::function_name syntax) within your packages code. (As stated previously, you should avoid using library() within your package code.) In the two functions we’ve included in our package, the only package that is required for use of our package is ggplot2. While we only have one function in our package at this point that utilizes this package, we know that we’ll likely be writing other themes over time and functions that have to do with plotting. For this reason, we’re going to add ggplot2 to our Imports field.  If your package depends on multiple other packages, it’s best to include them alphabetically, with each package listed on a separate line (and separated by a comma) so that they can be easily scanned by the human eye. Suggests Packages listed in this field can be used in your package, but aren’t required. For example, if you have a single function in your package that uses this external package, you may list it in Suggests. Packages in this field are not installed along with your package. If you list a package in Suggests, you avoid the user of your package from installing a package they may not need. However, within your package, you’ll want to be sure to include a stop() call in the function that uses your suggested package, prompting the user to install the package, for example: if(!requireNamespace(&quot;package_name&quot;, quietly = TRUE)){ stop(&quot;package_name&quot; required for use of this function. Please install it now.&quot;, call. = FALSE&quot;) } You may have noticed that testthat has already been added in the Suggests field for you. This means that testthat will not be installed upon installation of your package; however, if someone were to try to run the tests in your testthat/ directory using the testthat package, they would have to install testthat first.  The other notable bit about the testthat package in the DESCRIPTION file is the fact that “(&gt;= 2.1.0)” is included. This specifies the version of the package necessary. Specifically, for testthat here, the DESCRIPTION file is specifying that version 2.1.0 or a more recent version is required. It’s best practice to specify the minimum version necessary, rather than a specific version (== 2.1.0). Note that we could have included a minimum version along with ggplot2 in our Imports field if we felt that there was a minimum version required for our package to work. If we were to have added a version there, we would have added the version we were using at the time (i.e.”&gt;=3.2.0”). Depends This field used to be how package developers stated that your package “depended” on another package. However, this is no longer the case. You should almost always use Imports or Suggests now. We include this here to avoid confusion if you look at older package’s code. They may use this field heavily, but you should avoid this and instead use Imports and Suggests instead. 6.0.2.7 Other Fields You may also notice in your DESCRIPTION file two other fields: LazyData and Encoding. LazyData helps make access to data in your package easier. We’ll discuss this further in a later lesson. You should leave this field and value as is in your DESCRIPTION file. Encoding refers to how the characters used by the individual typing are stored and transmitted by the computer. There are a number of different systems for encoding. If you’ve heard for ASCII, UTF, or unicode, these refer to different systems used for encoding information within the computer. We note this here to specify that UTF-8 is an encoding that works on all platforms, and is the one included by default in your DESCRIPTION file. Unless you have a reason to specify a different encoding, leave the value of this field as is.  6.0.3 Install &amp; Restart Finally, while we haven’t added additionally functionality in this lesson, it’s a good idea to “Install and Restart” to make sure you haven’t messed up any of the expected formatting in this file before moving onto the next lesson. If it restarts R and loads you’re package without error, you’re ready to move on. If not, look back carefully at the syntax in your DESCRIPTION file before proceeding.  6.0.4 Summary This lesson was all about the DESCRIPTION file. This file is important for two reasons. First, it informs others what your package is all about, including information about who to contact if there’s a problem. Second, it specifies your package’s dependencies. Now that we have our minimal package truly ready to go, let’s move onto one of the most important aspects of package development - documentation! 6.0.5 Additional Resources Metadata, by Hadley Wickham and Jenny Bryan Writing R Extensions, from the R Core Team 6.0.6 Slides and Video Description Slides "],["documentation.html", "Chapter 7 Documentation", " Chapter 7 Documentation So far in this course we’ve gotten to the point where you should have a functional package. The package has two functions, two tests, and a complete DESCRIPTION file. However, while this package is usable by you at this point, it’s likely not usable by others …or even by future you. Without proper documentation, the utility of any package (or any piece of software for that matter!) is limited. 7.0.1 Why Document? Documentation is incredibly important and largely undervalued. We often get too focused on writing the code and don’t spend the required time to document our code. This lesson is a warning against that! As you write the code also write the documentation. You’ll save yourself time by doing it in the moment in that you won’t have to remember in the future what your code does. And, future you (and others if you release the package) will be able to use your package quickly and with ease. Now, writing good documentation takes practice. And, we all know that practice makes perfect. So, it’s best to practice writing good documentation on your own personal package so that when you release packages, you’re already good at it! Okay, enough of the pep talk, let’s get to documenting! 7.0.2 roxygen2 There are multiple types of documentation. In the next lesson we’ll talk about long-form documentation (in the form of vignettes), but in this lesson we’re going to focus on object documentation. This is the documentation that you see anytime you use ? or the help() functions in R. Previously we used the metaphor that R packages are like books in a library. The library stores all the packages you’ve installed. Extending this metaphor, if each R package is a book, documentation is the Glossary in the back of the book. It allows you to look up a function and receive definitions of what that function does and how to use it. The standard way of documenting objects (such as functions) is to write files including the object’s documentation and store them with the .Rd extension in the man/ directory. If you’re currently looking at your cbds package, you may be thinking to yourself “Um…there isn’t a man/ directory…” And you’re right, there isn’t…yet! Like package creation and testing, there’s an R package out there to help you write documentation. roxygen2 helps make documenting your code easier than manually creating any files and adding documentation. In using roxygen2 for your documentation, you’ll: have the correct file formats and structures automatically write code and documentation in the same files so that you can update them easily and at once (and not forget to go update your documentation…) get started writing documentation quickly and won’t have to worry about unnecessary details 7.0.2.1 General Procedure When adding documentation to objects in your package, the process for each function is as follows: Generate roxygen skeleton Document your function using roxygen comments Generate documentation - automatically convert the comments in your .R files into the required .Rd files Take a peak at the documentation you’ve generated using ? (or help()) 7.0.3 Documenting Functions Using the process mentioned above, roxygen2, and RStudio, we’ll discuss this process and the details you need to know to document your functions! 7.0.3.1 Step 1: Generate roxygen skeleton To get started documenting your package, roxygen comments – which are special comments that start with #' instead of just # – have to be added to the top of the .R file containing the object you’d like to document, you’ll first have to install the roxygen2 package (if you haven’t already): # install package install.packages(&quot;roxygen2&quot;) Then, return to (open) your check_na.R file from within the R/ directory. Once open, click on the wand icon within RStudio Cloud and select “Insert Roxygen Skeleton.”  This will get you started with what’s necessary for documenting your function using roxygen2. Specifically, this will add a block, or a number of lines at the top of your file containing roxygen comments. Blocks include tags. Tags take the format: @tag_name information  Note that within roxygen comments “@” therefore has a special meaning. If you ever want to use an actual “@” symbol (for email addresses, for example), you’ll need to use “@@”. 7.0.3.2 Step 2: Document The required information within this block are the title (first sentence) and description (second paragraph). Additional details are not required, but can be very helpful in actually making your function usable and well-documented. The third paragraph and beyond can include additional details about how the function works if needed. 7.0.3.2.1 Title &amp; Description For each object you document, the title should be a single line, written in sentence case (First word capitalized), and should not end in a period. The title should briefly explain the function’s purpose. The description should briefly (in a few sentences) describe what the function does. To see this clearly, let’s use ?ggplot (after loading the ggplot2 library into RStudio Cloud) to see how these pieces go on to look in the documentation.  Now, having seen an example, let’s add this specific information necessary to use your function. Title &amp; Description: check_na.R Within the check_na.R file, let’s first replace “Title” with “Return missingness info for a variable.” After this, we can hit return/Enter twice. This will automatically add roxygen comments. Here, we’ll add our function’s description: #&#39; Return missingness info for a variable #&#39; #&#39; Take variable as input and compute the number of total observations, #&#39; number of missing observations and number of non-missing observations. The first few lines of your .R file should now look as follows within RStudio Cloud:  As a brief aside, if you write a long description in a single line, you can use “Reflow Comment” (from the wand icon) to separate these comments into separate lines, so that no one line is too long (each line should be &lt;80 characters long) .  7.0.3.2.2 Documenting tags (@tags) Functions, which are what we’re focusing on documenting here use three tags typically: @param, @return, and @examples . These come after the introduction block that we just worked on and are used for the following purposes: @param: describes functions inputs (parameters) @return: describes the functions output @examples: provides R code that demonstrates this function working @param This tag takes the following form: @param name description. name should be replaced by the input parameter’s name for each input to your function. description should include a summary of the type of the parameter (i.e. numeric) and what the parameter does. It should start with a capital letter and end with a period. It can take multiple lines. Every single parameter must be documented. @return This tag takes the following form: @return description. description describes the output from the function and what type it takes @examples This tag is incredibly important. Many people look to examples first to get an understanding of what a function does and how to use it. This should include R code that can be run (executed) without error. (tags?): check_na.R Within check_na.R, we’ll want to document our input parameter, explain what the function returns, and provide an example of how to use the function. Within our roxygen comments this would look as follows: #&#39; @param variable Numeric, complex, or logical vectors. #&#39; #&#39; @return A matrix including the number of total, missing, and non-missing #&#39; observations #&#39; @export #&#39; #&#39; @examples #&#39; check_na(c(NA, NA, 3, &quot;cbds!&quot;, 4.5)) #&#39; check_na(iris$Sepal.Width) Note the following: When there’s more than one line for a tag, it must be indented for easy reading, as you see with the @return tag here We’ve included two examples, each of which will execute without error  !(tags? within check_na.R)(https://docs.google.com/presentation/d/1P3XII64p0lwSZQ7V_GTwYyEOX1WXRyn2fgHymY9iNfQ/export/png?id=1P3XII64p0lwSZQ7V_GTwYyEOX1WXRyn2fgHymY9iNfQ&amp;pageid=g5dd0b1f446_0_39) Also, you may see a tag in there that we haven’t talked about yet. The @export tag indicates that this function should be added to the NAMESPACE file. While we haven’t discussed that file and won’t be editing it manually, it’s important to know that functions included in the NAMESPACE are functions you want users of your package to have access to. So, if you want this function to be available to users, include the @export tag. Note that sometimes you’ll have functions that are used internally by other functions within your package and you won’t want them to be exported (available to users). However, for this first package and for most packages you write as you get started, you’ll likely want to @export each of your functions.  !(export? tag makes function usable to users)(https://docs.google.com/presentation/d/1P3XII64p0lwSZQ7V_GTwYyEOX1WXRyn2fgHymY9iNfQ/export/png?id=1P3XII64p0lwSZQ7V_GTwYyEOX1WXRyn2fgHymY9iNfQ&amp;pageid=g5dd0b1f446_0_46) 7.0.3.3 Step 3: Generate documentation Now that you’ve add the required information to your function in the roxygen comments, you’re ready to generate your documentation. To do this, return to the “Build” tab in RStudio Cloud, click on “More” and select “Document” from the drop-down menu.  This will generate the documentation and give you a readout of what it’s doing in the process:  This results in the the man/ documentation being generated for you.  Within the man/ directory, you’ll see that the .Rd file has been generated for you from the roxygen comments in your .R file. 7.0.3.4 Step 4: Look at your documentation! It’s finally time to take a look at your documentation using the ? function. To do so, “Install and Restart” from the Build tab.  You’re now ready to view your function’s technology! To do so, run ?check_na from the console. Your documentation will be viewable in the Help tab!  7.0.4 Documenting theme_cbds() We’ve walked through the steps to document a single function; however, you have a second function in your package! You’ll want to be sure to repeat these steps to document theme_cbds(). For example, your file could include the following roxygen comment block: #&#39; CBDS \\code{ggplot2} theme #&#39; #&#39; theme that includes black border only on the x- and y- axis, removes grid #&#39; lines and background, moves axis labels closer to axes, and allows #&#39; flexibility in font and font szie #&#39; #&#39; @param base_size Base font size (default: 12) #&#39; @param base_family Base font size (default: &quot;sans&quot;) #&#39; @param ... Arguments passed to \\code{\\link[ggplot2]{theme}} #&#39; #&#39; @return An object as returned by \\code{\\link[ggplot2]{theme}} #&#39; @seealso \\code{\\link[ggplot2]{theme}} #&#39; #&#39; @export #&#39; #&#39; @examples #&#39; require(ggplot2) #&#39; ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) + #&#39; geom_point() + #&#39; theme_cbds() There are a few new ideas in this block. Something we haven’t talked about yet is text formatting in .Rd documentation files.  Specifically, you can italicize (\\emph{text}), bold (\\strong{text}), or specify that text should be formatted as code (\\code{code}) within your documentation. Additionally you can include links to other documentation. For another function within the same package you would specify \\code{\\link{function_name}}. If you wanted, however, to include a link to a function in another R package, you would use \\code{\\link[other_package]{function_name}}. You can see an example text formatting and linking to other packages in the documentation for our theme_cbds() function.  Linking to places on the web is also possible using url{}, \\href{}, and \\email{}. Friendly reminder that the email would require @@. 7.0.5 Other Documentation In this lesson we’ve focused on documenting functions. Packages can also include datasets and classes. We’re not going to focus on those here; however, the format is very similar, using titles, descriptions, and tags, so once you get familiar with documenting functions, which are the most common object generated within packages, you’ll be able to pick up how to document these other objects. 7.0.6 Summary After this lesson you should have a DESCRIPTION file, two functions, tests for those functions, and documentation for your cbds package. You should be comfortable with generating roxygen comments and how to generate documentation once you’ve got the necessary information within your roxygen blocks! With that complete, let’s chat about long-form documentation in the form of vignettes! 7.0.7 Additional Resources Writing Documentation, by Karl Broman Object Documentation, by Hadley Wickham &amp; Jenny Bryan Writing R Extensions, from the R Core Team 7.0.8 Slides and Video Documentation Slides "],["vignettes.html", "Chapter 8 Vignettes", " Chapter 8 Vignettes So far in this course we’ve discussed what R packages are, reviewed functions, and created a package with a complete DESCRIPTION file (including all metadata) and two functions, including both tests and documentation for those functions. At this point our package is in pretty good shape. It has documentation explaining to users how to use each function, which is great! What it doesn’t have yet is long-form documentation in the form of vignettes. Rather than object documentation, which tells users how to use each individual piece of your package, vignettes help explain how the whole package fits together. It explains the functionality within your package and explains how it all works together, showing users through examples. 8.0.1 Vignettes Vignettes are long-form documentation in that they demonstrate how all the pieces of your package fit together. Admittedly, the package we’re creating in this course only has two pieces and they aren’t necessarily related; however, as you add functionality to your personal package, you could see that some pieces may be more related to one another. Grouping these together within your vignette than makes sense. And, the best way to do this involves technology with which you’re likely already familiar! Vignettes are written as R Markdown documents. (If you’re unfamiliar with R Markdown, refer back to the Introduction to R course.) This means that it’s very easy to intermingle code and text explaining the code/thought process together in the same document. Good vignettes that a good package and make it a great package because it makes it easier for users to just get started with the package. We’ll discuss how to create a vignette for our cbds package in this lesson, but as our package is a personal package, rather than the typical package which sets out to solve a particular problem, we are going to spend more time discussing vignettes for other packages that are well-documented to demonstrate just how helpful vignettes can be first! 8.0.2 Package Vignettes Package vignettes should accomplish a few things: Explain what the package does Include code demonstrating the functionality Show &amp; explain outputs from package’s functionality To do this successfully, it’s important to keep in mind that while you have written this code and been using these functions, your users have not. When they arrive at your vignettes, assume that the users are beginners. It’s best to put yourself in the mind of a beginner before you set out to write these documents. 8.0.2.1 How many vignettes? Packages can have as many vignettes as you’d like. Smaller packages likely only require a single vignette demonstrating how to get started and the main functionality. However, larger packages should likely be organized into multiple vignettes, with each vignette being self-contained. This means that each vignette can demonstrate a different part or set of tasks accomplished by your package. (However, if each vignette is completely unrelated to the others, it may be a good time to consider whether or not the functionality should be broken up into different packages!) 8.0.2.2 Viewing vignettes: browseVignettes() To see the vignettes in a package, you can use the browseVignettes() function with the package name of interest as an input. For example, to see the vignettes for googlesheets, which we’ll discuss in detail next, just execute browseVignettes(\"googlesheets\"). This will open up a URL in your web browser.  8.0.3 Vignettes: googlesheets To get a sense of what vignettes a package should have and what they look like, we’ll take a look more closely at the vignettes within the googlesheets package. At the time of writing this lesson, there are four vignettes in the googlesheets package: Formulas and formatted numbers googlesheets Basic Usage Managing Auth Tokens Use an alternative browser From their titles you can see that each plays a different role. The Basic Usage vignette is likely where most people would start. However, if after using this package, you found yourself running into trouble working with formulas in googlesheets, you’d likely check out the “Formulas and formatted numbers” vignette. If you were struggling to understand your authorization in the package, you would look at the “Managing Auth Tokens” vignette. And, if you wanted to use an alternative browser, you’d check out the last vignette listed above. As the “googlesheets Basic Usage” vignette is where most people would start, that is the vignette we’ll focus on most closely in this lesson. The Vignette is viewable at this link if you’d like to scroll through and have a look for yourself. (Note that vignettes can and should be updated overtime, so the images here may look different from what you see in the future!)  At the top of the vignette, in addition to the title, you have information about who authored the vignette and when it was last updated. And, in the most helpful vignettes, there is a table of contents where you can see clearly what’s included throughout the vignette. By looking at the topics here you can see that all of the basic functions you would want to accomplish using the googlesheets package (reading in a google sheet, creating a new google sheet, editing an existing sheet, etc.) are all documented within this vignette. Let’s focus in on “List Your Google Sheets”. If we click on that link within the table of contents, we’ll be brought to the part of the vignette that explains how to accomplish listing all of your google sheets.  In this bit of the vignette it becomes clear through the text provided what this function is used for and then, through the code, it becomes clear how to use it. Now, you could have read the documentation for that function and learned similar information, but with the vignette you then have all the information in one place to tell you what you can do after you list your Google Sheets using this function. It demonstrates how all of the pieces of the package fit together functionally through text that helps explain and code that demonstrates how it works! If you were to scroll through this vignette you would see that it’s rather long, but that’s OK. You don’t have to read the whole thing. If you look at the vignette and figure out the answer to the question that brought you there, you can move on. But, if you’re just getting started taking a look at the whole vignette can be very helpful! A vignette that helps its users most is the one that is well-organized, has clear examples, and has text to help explain the package. 8.0.4 Vignettes: stringr We could go through a similar process looking at the vignettes for another package we’re familiar with: stringr. By using browseVignettes(\"stringr\") you’ll be brought to a URL where you’ll see that this package has two vignettes. If you click on the HTML link next to “Introduction to stringr”, you’ll be brought to an HTML document that has a format that looks slightly different from what we saw in the googlesheets package but that contains very similar information. Here, we see an explanation in text of what the package is used for as well as descriptions of the functionality and examples of code and its outputs demonstrating this functionality. 8.0.5 Creating Vignettes Having looked at the output of these vignettes and what they look like for packages that have been released, let’s now step back and create a vignette for our cbds package! 8.0.5.1 Getting Started As with other lessons in this course, the usethis package has a function for you to get started writing your vignette! To do this we’ll use usethis::use_vignette(). What this does: Adds needed packages to DESCRIPTION file automatically for you Creates inst/doc and adds this directory to .gitignore (so that built vignettes are not version controlled) Adds vignettes/*.html and vignettes/*.R to .gitignore To do this, you may have to first install knitr (if you haven’t previously) and then run then use the following code: # install.packages(c(&quot;knitr&quot;, &quot;rmarkdown&quot;)) usethis::use_vignette(&#39;get-started&#39;, title = &quot;Getting Started&quot;) With this, you’ll see a new file (get-started.Rmd) has been added to your vignettes/ directory, that file has opened up for you, and, in your Console, you see a read-out of what changes have been made for you.  Note that within the get-started.Rmd document, some required YAML information at the top of the document as well as two code chunks have been added for you. But, aside from a line of code loading in your package (library(cbds)) being included for you, none of this is specific to your package yet. It’s time to personalize this document and make this vignette a helpful long-form piece of documentation to accompany your package!  8.0.5.2 Metadata The metadata at the top of your vignette file should look something like what you see here: --- title: &quot;Getting Started&quot; output: rmarkdown::html_vignette vignette: &gt; %\\VignetteIndexEntry{Getting Started} %\\VignetteEngine{knitr::rmarkdown} %\\VignetteEncoding{UTF-8} --- It has a title (specified when we used the use_vignette() function) which is specific to our package, but it does not have much more information. Let’s add a few fields to this portion of the document, to include additional helpful information, such as your name (as the author) and today’s date! Remember that each field and value is separated by a colon in this YAML section and that spacing matters. Each line we’ll add must start all the way to the left without any spaces or tabs before it. Specifically, we’ll leave the lines currently there alone, but let’s add the following two lines. Be sure to include your name as the author of your vignette. author: &quot;Jane Doe&quot; date: &quot;2022-04-27&quot; Note that 2022-04-27 will add today’s date any time this document is Knit. This helps readers of your vignette know the last time it was updated! We also want to point out that these are not the only fields that can be added to this document, but they are very important. 8.0.5.3 Vignettes in R Markdown The rest of this document is written as all other R Markdown documents you’ve worked with previously. There’s space for text (using Markdown syntax) and code (using R chunks)! And, after adding all necessary text and code to explain how to use your package, you’ll use Knitr - just like before! - to Knit your document (running all of the code within the R chunks!) into a beautiful HTML document! As we mentioned previously, vignettes are used to demonstrate the functionality of your package and how all the pieces fit together. This is the document where you get to show off what you’ve built and make it easier for others to use - a win-win! 8.0.6 Write for Beginners So, we’ve generated the file for our vignette, but we haven’t added any information to it, specific to our package’s functionality yet. Now we’ll fix that. And, we’ll do it while talking about how to write helpful and good vignettes. The most important piece of advice to remember when writing a vignette is that other people have not used your package before. It’s important to include all the necessary information someone new to your package would need to know. Don’t skip steps that you’re familiar with because others will not be as familiar. Include helpful examples and text explaining them so that others, who are beginners, will be able to follow along with ease. Okay, with that in mind, let’s add some examples and text to our vignette! 8.0.7 The Process The general process for writing a helpful vignette includes an interactive process where for each piece of your package you include enough text to explain to a beginner what’s going on and code to demonstrate how to use your package’s functionality. After adding text and code, it’s best to run the code chunk to ensure that there are no errors. You do this iteratively until you have all the necessary functionality of your package explained. Once you’ve got a full vignette, you build the vignette and you’re all set! Let’s do this for our cbds package now! 8.0.7.1 Step 1: Add Text For large packages, sometimes you’ll need a lot of introductory text or even a section dedicated to explaining your package, but for our package - which is primarily to hold functions for our personal use - we’ll just include a brief paragraph introducing the package. After our brief introduction, the functions in this package revolve around working with data. So, we’ll introduce a dataset that we’ll then use throughout our vignette.  8.0.7.2 Step 2: Add code To work with this dataset, we’ll load the ggplot2 package and then take a look at the diamonds dataset. Note that to do this, we include the code in a R Markdown code chunk.  8.0.7.3 Step 3: Run code chunk To ensure that there are no errors in the code you’ve written, it’s always a good idea to run the code chunk before moving on to the next part of your vignette.  8.0.7.4 Step 4: Repeat Steps 1-3 At this point, we have an introduction and data to work with, so we’re ready to continue adding text and code to demonstrate how the functions in our package work. We have two functions currently, so we’ll add an H1 header for each and then include text and code to demonstrate how they work. First, we demonstrate using text, code, and code output how a user would use the function check_na()  Second, we’ll want to document our theme_cbds() function. Remember this is a custom theme to be applied to ggplot2 plots. So, it would likely be helpful for users to be able to visualize the changes from default plots to what your theme produces. Thus, it’s a good idea to include what the plot would look like before applying your theme.  Then, you can demonstrate what this plot would look like - using both text and code to explain - with your function:  Note that text explaining the code can be included before the code and text explaining the output of the code can be included after the code chunk to summarize what’s going on.  Finally, sometimes, it can helpful to readers to demonstrate explicitly that a function works in different contexts. For example, we can include an additional plot, demonstrating what this would look like for a barplot (using a categorical variable).  At this point, our full vignette includes the following a YAML with modified metadata at the top, text introducing our package, and text, code and output demonstrating how to use the functions within our package. We’re now ready for the final step - building our vignette! 8.0.7.5 Step 4: Build Vignette To accomplish this, we’ll first note that using “Clean &amp; Rebuild” from the Build tab will NOT build your vignettes for you. This is to save time so that your Vignettes are not re-generated every time you change something small in your package. However, at this point we want to build our vignettes. To do so we’ll want to use the build() function from devtoools. To use this, first add devtools to your DESCRIPTION file.  Then, install the package on RStudio Cloud for immediate use: install.packages(&quot;devtools&quot;) Now, we can create our package bundle and generate vignettes by using: devtools::build()  Note that the output indicates that our vignettes have been built (along with the rest of the package)! 8.0.8 Summary In this lesson we looked through examples of vignettes in other package and discussed how these long-form pieces of documentation can be really helpful for explaining and demonstrating how others should go about using your package. While these documents are less helpful for packages you don’t plan to release and that are primarily for your use, it’s important to get practice writing good vignettes. So, we added a vignette to our cbds package and demonstrated how to build vignettes using devtools. At this point you have a pretty complete and well-documented package that includes two documented functions, unit tests, and a vignette. In the final two lessons we’ll discuss how to add data to your package, which, for data analysis, is often helpful and how to release your package on GitHub! 8.0.9 Additional Resources Vignettes, by Hadley Wickham &amp; Jenny Bryan Package Vignette, by Yihui Xie, J. J. Allaire, &amp; Garrett Grolemund Writing Vignettes, by Karl Broman 8.0.10 Slides and Video Vignettes Slides "],["data.html", "Chapter 9 Data", " Chapter 9 Data We noted in the last lesson that at this point we have a pretty complete package. We have functions, unit tests, documentation, and a vignette. However, what we haven’t talked about yet is the fact that sometimes, packages require data. This generally takes one of three forms: Data Available to the User Data Your Functions Need Raw Data We’ll walk through each of these in this lesson, explain how it relates to your R package, and demonstrate how to utilize the usethis package to make your life easier when adding data. 9.0.1 Data Available to the User As you start developing packages, making data available to the user is likely what you’ll find yourself doing most frequently when it comes to data. This is because having datasets available to users that demonstrate the functionality of your package. For example, think about the datasets available from ggplot2, such as diamonds or msleep. They’re great for demonstrating the various types of plots that can be made using ggplot2! It can be really helpful to include these types of datasets with your package for users to utilize. Datasets you want to be available to your user should be stored in the data/ directory. These are referred to as external or exported datasets. You may notice at this point, however, that in your cbds package, there isn’t yet a data/ directory. This is where usethis comes into play. To store data in the data/ directory, you’ll use usethis::use_data() and specify the objects that you want to be saved. In the example below, if you had a dataset about trees stored in the object df_trees, the following would create the .rda file appropriate for your package and put it in the right directory. # for external use `usethis::use_data(df_trees)` Note that you get a readout of the fact that the data/ directory has been created for you and that your dataset has been saved within that directory.  To double check this, you would look at your Files tab, where you would now see that the data/ directory is there for you.  Within that directory, you’ll find that your object df_trees is now stored within data/ as a .rda file: df_trees.rda. Unlike CSVs, this R Data file extension is something we haven’t used a ton, but this is a great way to store data within an R package and is the most efficient format for making data available to users within a package.  9.0.2 Data Required By Your Functions In addition to data that you want your users to have access to, sometimes your functions require data and you want that data to be available to your functions but not to all package users. So, the data can’t be stored in data/. Data for your use by your package’s functions is referred to as internal data. Internal data are generated again using the use_data() function from usethis; however, you’ll need to change an input argument: internal = TRUE. # for internal use usethis::use_data(df_trees, internal = TRUE)  Notice that these data are not stored in data/ and instead are stored in the R/ directory in a file named sysdata.rda.  As a reminder, these data are only available for use inside your package. 9.0.3 Raw Data Less frequently than providing users with an example dataset (that you’ve made available to them as discussed earlier in the lesson), you may find a need to provide raw data or original files with your package. These raw data files are often stored in inst/extdata/. To automatically generate the scripts (using usethis) you’ll use to generate raw data files (and the accompanying script), you would use the usethis::use_data_raw() function: # for raw data usethis::use_data_raw(&quot;trees_raw&quot;)  As previously, you get a helpful readout of what has been done for you as well as what still remains for you to do. Specifically, the example above creates a data-raw/ directory for you.  It also generates a script file of the name you specified within the data-raw/ directory, and opens that script file.  Within the script file, there is a comment prompting you to add code here that takes your raw data file and gets it into the cleaner form that you’ve shared with users. You would add your code to take your raw dataset from its raw form into the form shared with your users (in your data/ directory). One example of this approach being used comes from Hadley Wickham’s babynames package. Within that package cleaned up data from the USA Social Security Administration are made available to users (in the data/ directory). However, to make those data usable by others from the package, Hadley Wickham had to gather and clean the data. The code to accomplish this is stored within the data-raw/ directory.  At the end of this script, he saves the data file as a CSV into the data-raw/ directory. This way his workflow is completely reproducible - anyone looking at the code in this package is completely clear on what data were used (from the information in data-raw/) and can get to using the dataset (because the clean version is stored in data/) Note that to access raw data file from a package you utilize system.file using the following syntax: system.file(&quot;extdata&quot;, &quot;births.csv&quot;, package = &quot;babynames&quot;) Here, “extdata” refers to the directory where the data are stored in the package, “births.csv” refers to the name of raw data file, and “babynames” refers to the package from which you want to retrieve this data. 9.0.4 Documenting Datasets Now that we’ve discussed the main ways of including data within a package, we have to take a second to talk about documenting data. Datasets stored in data/ (so, those external datasets you want your users to be able to use) are made available to users of your packages, just like functions! So, just like functions, external data must be documented. While we won’t go into too many specifics here, roxygen2 blocks are also used to document datasets making the process familiar. These roxygen2 blocks should be saved in the R/ directory in a file named data.R. Here is what the documentation looks like for the births dataset from the babynames package we were just talking about #&#39; Births #&#39; #&#39; Live births data from census.gov. #&#39; #&#39; @format A data frame: #&#39; \\describe{ #&#39; \\item{year}{Year} #&#39; \\item{births}{Number of live births, rounded to nearest 1000}} &quot;births&quot; Within this roxygen2 bloc, we see the name of the dataset and a brief description. However, the @format tag is new. This should describe the dataset. For a dataframe, you must provide users with a list that describes each variable in the dataset you’re sharing. Here, we see that this dataset has two variables: year and births Note that @export is not included (as you would for an exported function). Be sure not to include @export when documenting a dataset. Finally, only data being made available to users have to be documented. You don’t need roxygen2 blocks for internal data or raw data. 9.0.5 Summary In this lesson we cover the final piece of what you’ll typically add to a package - data! Now, there are other topics surrounding creating R packages that we have not covered in the lessons here. In the next lesson we’ll talk about how to get your package onto GitHub and use Travis CI, but we don’t cover in detail what you’ll need to do to get your package onto CRAN, the NAMESPACE, or Compiled Code. So, if you want to learn even more the R Packages book by Hadley Wickham and Jenny Bryan is a great resource and is where tons of information in these lessons has come from. We also link to the appropriate section in that book after each lesson in this course. 9.0.6 Additional Resources External Data, by Hadley Wickham &amp; Jenny Bryan Including Datasets, by Karl Broman 9.0.7 Slides and Video Data Slides "],["release.html", "Chapter 10 Release", " Chapter 10 Release At this point, we’ve got our cbds package with two functions, documentation, unit tests, and a vignette. It’s only meant to be a package for our use at this point, so we’re not planning to release this package, but you should be familiar with how to release a package generally. So, we’ll walk through those steps in this lesson. Releasing a package generally includes making it available to the public. There are a few main repositories for R packages. We’ve discussed these before, but I’ll remind you that CRAN is the general place to R package release. When you run install.packages(), packages are located on CRAN and then installed. However, there are a number of requirements for packages included on CRAN to ensure consistency between packages and that all packages will work for all other users. There is a similar platform called Bioconductor for R packages related to bioinformatics. Finally, packages can be released on GitHub. The requirements for this are lower than for releasing a package on CRAN or Bioconductor. This means that for packages to be widely used, you’ll want to put them on CRAN. For packages for your own use or while they’re still in development, GitHub is the way to go! GitHub is also the simplest way to release a package. This is great because we’re already familiar with working with GitHub, so it won’t require a totally new skill. Additionally, even though we’re not planning to release this package to the world yet, by putting this package on GitHub means that it will be version controlled, which we should do with all of our work - a win-win! 10.0.1 To GitHub To get started on getting your package on GitHub, it’s important that you’re currently within your package’s project. (If you’re unsure, you can click on the Rproj for your package: cbds.Rproj to take you there. If you’re not yet in the correct R project, you’ll be asked if you want to switch to that project. Switch now! Alternatively, if you’re already there, a window with the Project Options will pop up, indicating you’re where you need to be and you can just click Cancel.) 10.0.1.1 GitHub Key Setup Once you’re sure you’re within your package’s R project, the next thing we’re going to do is set up an SSH key so that you don’t have to put your username and password in every time you push to GitHub. Now, we’ll note that this SSH key will only work for this workspace. Any other workspaces in RStudio Cloud will require you to set up a separate SSH key. To get started, we’ll first let git know who you are as we’ve done previously. Be sure to include your GitHub username and email when you run the following in the Terminal (not the Console): git config --global user.name &quot;JaneEverydayDoe&quot; git config --global user.email &quot;Jane.Everyday.Doe@gmail.com&quot;  Global RSA Key Now, it’s time to set up the global options for the workspace, which will allow you to set up an SSH key for the workspace. Go to the Tools menu and select “Global Options” from the drop-down menu.  Within this window, select Git/SVN from the menu on the left, then click on “Create RSA Key…”  In the window that pops up, choose a passphrase and type it into both boxes. Remember this passphrase as you will need to type it in shortly. Then, click “Create”.  This will return you to the Options window. On this window, click on “View public key”. In the window that pops up, copy all the text for your key.  You’ve now generated an RSA key for your project. It’s time to let GitHub know about this key so that it can verify who you are. To do so, go to [http://github.com/keys]. In this window, click on “New SSH key”.  Create a Title for this Key and then paste the text you just copied from RStudio Cloud into this box. Then, click Add SSH key.  Project Options You’ve now established a global RSA key for this workspace on RStudio Cloud. Now, it’s time to connect this specific project to a repo on GitHub. To do so, select “Project Options” from the Tools drop-down menu on RStudio Cloud.  As with the Global options, select “Git/SVN” from the menu at left. Then, select “Git” from the Version control system drop down menu.  You will be asked two questions to confirm that you want a new git repository and that you want to restart RStudio. Select Yes for both.  At this point you now have a new Git tab for use within RStudio Cloud right next to the Build tab we’ve been using throughout this course  If you click on this tab, you’ll see a list of the files in your R project. The question marks to the left of each file indicates that these files are untracked. (As a reminder, this means that git has not seen these before. You have not yet staged them.) An icon with an M indicates a file that has been modified. A D indicates a file has been deleted. And, an A indicates that it has been added (or staged).  If you then click on Diff, you’ll be brought to a new window. Here, if you click on any file, you can see the changes since your last commit. As this is our first commit, everything is new, thus it’s all in green. In the future, deleted lines are shown in red.  To stage all of these files, click the check boxes to the left for all the files. Then, add a helpful commit message on the right, and click “Commit”.  A window will pop up giving you an update of what has changed with this commit.  Connect to remote (GitHub) At this point, we’ve generated an RSA key and shared that key with GitHub. We’ve also committed all our new files using git on RStudio Cloud. Now, it’s time to take these files from RStudio Cloud and put them on GitHub. To do this, you’ll have to Create a repository as we’ve done before at [http://github.com/new]. Add the package name as the name of the repo and include a short Description. Leave all other fields as is and click “Create repository.”  On the screen that shows up next there are instructions about how to connect GitHub with your files on RStudio Cloud. To do this, be sure to toggle “SSH” at the top if it is not already. Then copy the highlighted text from GitHub. It should look similar to what you see here, but with your GitHub username: git remote add origin git@github.com:JaneEverydayDoe/cbds.git git push -u origin master  Copy this text and then paste it into the Terminal on RStudio Cloud. Upon pressing enter (and executing these commands), you will be asked first if you want to use the RSA key fingerprint that you generated. Type “yes”. Then, you will be asked for your passphrase. This is the passphrase you created when generating your RSA key. Type that now and press enter.  And, with that, your package will be pushed to GitHub!  As an added bonus, you’ll no longer have to type in your username and password every time you want to make a change on GitHub thanks to your RSA key setup! 10.0.2 Installing From GitHub Once your built package is on GitHub, others (including yourself) are able to install and use your package. To install your (or anyone’s) package from GitHub, you use the following approach: # install from GitHub devtools::install_github(&quot;username/packagename&quot;) So, for this package we would use the following in the Console: # install from GitHub devtools::install_github(&quot;janeeverydaydoe/cbds&quot;) With that, the package has been installed. Then, you just have to load it using library(cbds) to start using the functionality within the package.  10.0.3 Package Checking In this lesson we noted that there are stricter rules and requirements for packages if you want to release them on CRAN or Bioconductor. While we won’t be going into detail here, if you want more details, the R Packages book is a great resource with lots of information about building a package for CRAN. Nevertheless, we do want to mention that there is a way to check your packages for common issues. There is a helpful function R CMD check that you can use to check for these common issues. The more frequently you check your package during development, the better. This way you identify issues along the way shortly after you’ve written a function or test. This avoids having tons of issues at the end of package development and will make your life easier overall at the end when you release the package. The easiest way to check your package is to click on the Check icon within the Build tab.  This will start running a number of checks for you, giving you a readout of all the checks it’s carrying out. This checks all the aspects of your package that we’ve covered in this course, including the package’s structure, metadata, NAMESPACE, data code, tests, vignettes, and documentation.  At the end of all of these checks, you’ll get a readout of what was found:  Here you see that there was 1 warning. The warning here has to do with an outside requirement, qpdf. If you google this warning, you’ll see that this warning is really only applicable if you want to submit your package to CRAN and that it requires installing qpdf. However, as we don’t want to submit to CRAN at this point, we’re in pretty good shape with no errors, notes, or other warnings! Generally, errors should be fixed regardless of whether you’re submitting to CRAN. Warnings are likely to cause an issue if you submit to release your package on CRAN. Notes are mild issues. It’s best to ultimately have none of each of these, but it’s not essential to address them all if the package is just for your own use. 10.0.4 Continuous Integration: Travis One step beyond manually checking each time you make changes to your package is to set up continuous integration. This will run these checks for you automatically, each time you push to GitHub. To do this, we’ll use Travis. ** Travis Account** To start using Travis with your R package, you’ll first want to create a Travis account. Go to [https://travis-ci.org/profile] and click “Sign in with GitHub”  On the next screen click, “Authorize travis-ci”.  Once authorized, you’ll want to click on the repo that you’d like to use with Travis. Here, we’ll click on cbds.  You’ll get a note that this is not an active directory. Click “Activate repository” to activate. You’ll get a note that there are no builds for this repository. To change that, let’s return to RStudio Cloud and set up Travis on that end.  ** usethis::use_travis** To accomplish integrating Travis with RStudio on the RStudio Cloud end, there’s another helpful function from the usethis package: usethis::use_travis() Execute this function and you’ll see that a file travis.yml is generated.  If you open this up, you’ll notice that a few lines of information have been added there.  What these lines accomplish is that every time you push to GitHub or every time someone submits a pull request to your repo, devtools::check() (what is run when you click the “Check” icon) is automatically run. You’ll learn about failures immediately, allowing you to address them more easily. Note that this yaml file can be customized. We’ll stick with the defaults here, but know that you can read about more options at [http://docs.travis-ci.com/user/deployment/]. Having added this yaml file, we want to push these changes to GitHub. Return to the Git tab, select to stage these files, add a commit message, and commit these files. Then, be sure to push these files to GitHub. (You may be asked your passphrase again.)  Upon pushing these changes to GitHub, Travis CI will automatically run devtools::check() for you. You can see Travis running on your Travis account. Yellow indicates a build that is running. Green indicates a successful build. Red indicates an error and something you’ll want to address as soon as possible to avoid issues down the line.  It may take a while (~10 minutes) for your Travis build to generate. However, eventually it will either pass (and turn green) or fail (and be red). You’ll also get a log indicating where it may have failed.  If you followed the instructions here, your build will likely have failed. This was intentional. Builds fail frequently when you’re just getting started! So, let’s take a look at where we went wrong. By looking at the output on Travis we see that warnings were found. Well, this makes sense, we know that there are warnings. We just don’t care about them at this point because we’re not trying to put this package on CRAN. So, we can tell Travis to not treat warnings as errors by adding the following to our travis.yml file: warnings_are_errors: false  After saving this file, we stage, commit, and push our changes to GitHub! Travis will then automatically re-build.  Eventually, Travis should indicate a successful build with a green check mark! Upon refresh, the badge at the top should indicate the build is “passing”. Success!  10.0.5 Versioning We specified a version number within our DESCRIPTION file in an earlier lesson in this course, but we didn’t fully explain how versioning works. We mentioned previously that: your package’s version will contain three numbers, separated by periods. Those numbers correspond to ... For example, 1.0.0 would be the first released version of your package. As you patch the package (make a small change), the patch value would increase, such that the next version may be 1.0.1. We’ll discuss what major, minor, and patch mean in the context of versioning in the final lesson in this course. So far, we’ve been using the version “0.0.0.9000”. The fact that there are three zeroes indicates that this is still a development version. 9000 is a somewhat arbitrary number, but it’s helpful to use this to indicate that this is not a “typical” released version. Upon release, you’ll want to drop the dev number, which is why your first released version is “1.0.0”. Here the major version is “1” and the minor and patch are both “0”. If you were to fix bugs without adding new functionality to your package, you’d want to increase your patch. For example, you would update your version to be “1.0.1.” However, patch numbers remain 0 from one version to the next. If you included a few new features and bug fixes, this is a minor release, so you would increase the middle number by 1. These are the most common changes to package version. It’s totally fie if you need more than one digit after many minor versions (i.e. 1.20.0). A major release is typically reserved for large package changes where users of the old major release will not be able to use the new version as so much has changed. This would require increasing the first number in your version by 1. These happen less frequently than minor version changes or patches. To change the version in your package, you would edit the version number in your DESCRIPTION file, Check, and rebuild your package before pushing the changes to GitHub. 10.0.6 README.md Last but not least, a README.md can be very helpful to others who stumble upon your released package. Similar to a less-detailed vignette, the README included with your package should explain why someone should use your package, briefly demonstrate how to use it, and include information about how to install the package. The usethis package (of course!) has two helpful functions to generate these files for you which will generate the template README file and add it to .Rbuildignore. # to include markdown-formatted text usethis::use_readme_md() # to include markdown-formatted text # AND R code chunks usethis::use_readme_rmd() For our cbds package, we’ll write a very brief README to demonstrate the process, but for a package released to others, you’d want a more helpful README, similar to that of the googlesheets or dplyr packages.  For now, we’ll generate a Markdown README to demonstrate the process in our package using usethis::use_readme_md(). This creates the README.md file and opens it up for you to edit.  In the file that is generated, for now, we can just edit the text to include that this is a personal package and demonstrate how to install it. We’ll remove example for now until it becomes a full package for release.  Once edited, you’ll click Preview to knit the file. You’re then ready to add, commit, and push the changes to your repo.  Your Travis build will automatically begin and you’re package will be checked and ready to go! 10.0.7 Summary In this lesson we’ve covered a whole lot. We’ve discussed how to release this package on GitHub, how to check your package before release, how to integrate this with Travis CI for automated checking, how to version your package, and briefly what to include in a README. We have not, however, discussed the ins and outs of how devtools::check() works, what precisely is checked, and how to deal with the warnings, errors, and notes you receive. If you’re looking to release your package on CRAN, you’ll ultimately have to get good at deciphering these. The R Packages book can be a great resource for further understanding on this and all topics covered in this course. 10.0.8 Additional Resources Git &amp; GitHub, from R Packages by Hadley Wickham &amp; Jenny Bryan Automated Checking, from R Packages by Hadley Wickham &amp; Jenny Bryan Releasing a Packages, from R Packages by Hadley Wickham &amp; Jenny Bryan 10.0.9 Slides and Video Release Slides "],["about-the-authors.html", "About the Authors", " About the Authors These credits are based on our course contributors table guidelines.     Credits Names Pedagogy Lead Content Instructor(s) FirstName LastName Lecturer(s) (include chapter name/link in parentheses if only for specific chapters) - make new line if more than one chapter involved Delivered the course in some way - video or audio Content Author(s) (include chapter name/link in parentheses if only for specific chapters) - make new line if more than one chapter involved If any other authors besides lead instructor Content Contributor(s) (include section name/link in parentheses) - make new line if more than one section involved Wrote less than a chapter Content Editor(s)/Reviewer(s) Checked your content Content Director(s) Helped guide the content direction Content Consultants (include chapter name/link in parentheses or word “General”) - make new line if more than one chapter involved Gave high level advice on content Acknowledgments Gave small assistance to content but not to the level of consulting Production Content Publisher(s) Helped with publishing platform Content Publishing Reviewer(s) Reviewed overall content and aesthetics on publishing platform Technical Course Publishing Engineer(s) Helped with the code for the technical aspects related to the specific course generation Template Publishing Engineers Candace Savonen, Carrie Wright Publishing Maintenance Engineer Candace Savonen Technical Publishing Stylists Carrie Wright, Candace Savonen Package Developers (ottrpal) John Muschelli, Candace Savonen, Carrie Wright Art and Design Illustrator(s) Created graphics for the course Figure Artist(s) Created figures/plots for course Videographer(s) Filmed videos Videography Editor(s) Edited film Audiographer(s) Recorded audio Audiography Editor(s) Edited audio recordings Funding Funder(s) Institution/individual who funded course including grant number Funding Staff Staff members who help with funding   ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 4.0.2 (2020-06-22) ## os Ubuntu 20.04.3 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Etc/UTC ## date 2022-04-27 ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date lib source ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.0.3) ## bookdown 0.24 2022-02-15 [1] Github (rstudio/bookdown@88bc4ea) ## callr 3.4.4 2020-09-07 [1] RSPM (R 4.0.2) ## cli 2.0.2 2020-02-28 [1] RSPM (R 4.0.0) ## crayon 1.3.4 2017-09-16 [1] RSPM (R 4.0.0) ## desc 1.2.0 2018-05-01 [1] RSPM (R 4.0.3) ## devtools 2.3.2 2020-09-18 [1] RSPM (R 4.0.3) ## digest 0.6.25 2020-02-23 [1] RSPM (R 4.0.0) ## ellipsis 0.3.1 2020-05-15 [1] RSPM (R 4.0.3) ## evaluate 0.14 2019-05-28 [1] RSPM (R 4.0.3) ## fansi 0.4.1 2020-01-08 [1] RSPM (R 4.0.0) ## fs 1.5.0 2020-07-31 [1] RSPM (R 4.0.3) ## glue 1.6.1 2022-01-22 [1] CRAN (R 4.0.2) ## htmltools 0.5.0 2020-06-16 [1] RSPM (R 4.0.1) ## jquerylib 0.1.4 2021-04-26 [1] CRAN (R 4.0.2) ## knitr 1.33 2022-02-15 [1] Github (yihui/knitr@a1052d1) ## lifecycle 1.0.0 2021-02-15 [1] CRAN (R 4.0.2) ## magrittr 2.0.2 2022-01-26 [1] CRAN (R 4.0.2) ## memoise 1.1.0 2017-04-21 [1] RSPM (R 4.0.0) ## pkgbuild 1.1.0 2020-07-13 [1] RSPM (R 4.0.2) ## pkgload 1.1.0 2020-05-29 [1] RSPM (R 4.0.3) ## prettyunits 1.1.1 2020-01-24 [1] RSPM (R 4.0.3) ## processx 3.4.4 2020-09-03 [1] RSPM (R 4.0.2) ## ps 1.3.4 2020-08-11 [1] RSPM (R 4.0.2) ## purrr 0.3.4 2020-04-17 [1] RSPM (R 4.0.3) ## R6 2.4.1 2019-11-12 [1] RSPM (R 4.0.0) ## remotes 2.2.0 2020-07-21 [1] RSPM (R 4.0.3) ## rlang 0.4.10 2022-02-15 [1] Github (r-lib/rlang@f0c9be5) ## rmarkdown 2.10 2022-02-15 [1] Github (rstudio/rmarkdown@02d3c25) ## rprojroot 2.0.2 2020-11-15 [1] CRAN (R 4.0.2) ## sessioninfo 1.1.1 2018-11-05 [1] RSPM (R 4.0.3) ## stringi 1.5.3 2020-09-09 [1] RSPM (R 4.0.3) ## stringr 1.4.0 2019-02-10 [1] RSPM (R 4.0.3) ## testthat 3.0.1 2022-02-15 [1] Github (R-lib/testthat@e99155a) ## usethis 2.1.5.9000 2022-02-15 [1] Github (r-lib/usethis@57b109a) ## withr 2.3.0 2020-09-22 [1] RSPM (R 4.0.2) ## xfun 0.26 2022-02-15 [1] Github (yihui/xfun@74c2a66) ## yaml 2.2.1 2020-02-01 [1] RSPM (R 4.0.3) ## ## [1] /usr/local/lib/R/site-library ## [2] /usr/local/lib/R/library "],["references.html", "Chapter 11 References", " Chapter 11 References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
